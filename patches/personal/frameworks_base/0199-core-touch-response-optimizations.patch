From b2b187f7e608f37609c0b99b3f9485ee7c81d18b Mon Sep 17 00:00:00 2001
From: Victor Bo <bvoid@yandex.ru>
Date: Wed, 16 Dec 2020 14:52:36 -0500
Subject: [PATCH 199/211] core: touch response optimizations

  from
  https://github.com/syberia-project/platform_frameworks_base/commit/aa79ead72aeaaae2b29f384403eda2119a5492d6
---
 core/java/android/view/Choreographer.java     | 57 ++++++++++++-
 .../java/android/view/InputEventReceiver.java | 15 ++++
 core/java/android/widget/AbsListView.java     | 81 ++++++++++++++++++-
 core/jni/android_view_InputEventReceiver.cpp  | 32 +++++++-
 4 files changed, 180 insertions(+), 5 deletions(-)

diff --git a/core/java/android/view/Choreographer.java b/core/java/android/view/Choreographer.java
index 987edf7761d..3038454f1f0 100644
--- a/core/java/android/view/Choreographer.java
+++ b/core/java/android/view/Choreographer.java
@@ -84,6 +84,7 @@ public final class Choreographer {
 
     // Prints debug messages about jank which was detected (low volume).
     private static final boolean DEBUG_JANK = false;
+    private static final boolean OPTS_INPUT = true;
 
     // Prints debug messages about every frame and callback registered (high volume).
     private static final boolean DEBUG_FRAMES = false;
@@ -151,6 +152,11 @@ public final class Choreographer {
     private static final int MSG_DO_SCHEDULE_VSYNC = 1;
     private static final int MSG_DO_SCHEDULE_CALLBACK = 2;
 
+    private static final int MOTION_EVENT_ACTION_DOWN = 0;
+    private static final int MOTION_EVENT_ACTION_UP = 1;
+    private static final int MOTION_EVENT_ACTION_MOVE = 2;
+    private static final int MOTION_EVENT_ACTION_CANCEL = 3;
+
     // All frame callbacks posted by applications have this token.
     private static final Object FRAME_CALLBACK_TOKEN = new Object() {
         public String toString() { return "FRAME_CALLBACK_TOKEN"; }
@@ -181,7 +187,10 @@ public final class Choreographer {
     private long mFrameIntervalNanos;
     private boolean mDebugPrintNextFrameTimeDelta;
     private int mFPSDivisor = 1;
-
+    private int mTouchMoveNum = -1;
+    private int mMotionEventType = -1;
+    private boolean mConsumedMove = false;
+    private boolean mConsumedDown = false;
     /**
      * Contains information about the current frame for jank-tracking,
      * mainly timings of key events along with a bit of metadata about
@@ -296,6 +305,16 @@ public final class Choreographer {
         return sSfThreadInstance.get();
     }
 
+    /**
+     * {@hide}
+     */
+    public void setMotionEventInfo(int motionEventType, int touchMoveNum) {
+        synchronized(this) {
+            mTouchMoveNum = touchMoveNum;
+            mMotionEventType = motionEventType;
+        }
+    }
+
     /**
      * @return The Choreographer of the main thread, if it exists, or {@code null} otherwise.
      * @hide
@@ -626,6 +645,42 @@ public final class Choreographer {
     private void scheduleFrameLocked(long now) {
         if (!mFrameScheduled) {
             mFrameScheduled = true;
+            if (OPTS_INPUT) {
+                Trace.traceBegin(Trace.TRACE_TAG_VIEW, "scheduleFrameLocked-mMotionEventType:" + mMotionEventType + " mTouchMoveNum:" + mTouchMoveNum
+                                    + " mConsumedDown:" + mConsumedDown + " mConsumedMove:" + mConsumedMove);
+                Trace.traceEnd(Trace.TRACE_TAG_VIEW);
+                synchronized(this) {
+                    switch(mMotionEventType) {
+                        case MOTION_EVENT_ACTION_DOWN:
+                            mConsumedMove = false;
+                            if (!mConsumedDown) {
+                                Message msg = mHandler.obtainMessage(MSG_DO_FRAME);
+                                msg.setAsynchronous(true);
+                                mHandler.sendMessageAtFrontOfQueue(msg);
+                                mConsumedDown = true;
+                                return;
+                            }
+                            break;
+                        case MOTION_EVENT_ACTION_MOVE:
+                            mConsumedDown = false;
+                            if ((mTouchMoveNum == 1) && !mConsumedMove) {
+                                Message msg = mHandler.obtainMessage(MSG_DO_FRAME);
+                                msg.setAsynchronous(true);
+                                mHandler.sendMessageAtFrontOfQueue(msg);
+                                mConsumedMove = true;
+                                return;
+                            }
+                            break;
+                        case MOTION_EVENT_ACTION_UP:
+                        case MOTION_EVENT_ACTION_CANCEL:
+                            mConsumedMove = false;
+                            mConsumedDown = false;
+                            break;
+                        default:
+                            break;
+                    }
+                }
+            }
             if (USE_VSYNC) {
                 if (DEBUG_FRAMES) {
                     Log.d(TAG, "Scheduling next frame on vsync.");
diff --git a/core/java/android/view/InputEventReceiver.java b/core/java/android/view/InputEventReceiver.java
index 25a4108c612..b426e2962c9 100644
--- a/core/java/android/view/InputEventReceiver.java
+++ b/core/java/android/view/InputEventReceiver.java
@@ -46,6 +46,7 @@ public abstract class InputEventReceiver {
 
     // Map from InputEvent sequence numbers to dispatcher sequence numbers.
     private final SparseIntArray mSeqMap = new SparseIntArray();
+    Choreographer mChoreographer;
 
     private static native long nativeInit(WeakReference<InputEventReceiver> receiver,
             InputChannel inputChannel, MessageQueue messageQueue);
@@ -220,6 +221,20 @@ public abstract class InputEventReceiver {
         onInputEvent(event);
     }
 
+    // Called from native code.
+    @SuppressWarnings("unused")
+    private void dispatchMotionEventInfo(int motionEventType, int touchMoveNum) {
+        try {
+            if (mChoreographer == null)
+                mChoreographer = Choreographer.getInstance();
+
+            if (mChoreographer != null)
+                mChoreographer.setMotionEventInfo(motionEventType, touchMoveNum);
+        } catch (Exception e) {
+            Log.e(TAG, "cannot invoke setMotionEventInfo.");
+        }
+    }
+
     /**
      * Factory for InputEventReceiver
      */
diff --git a/core/java/android/widget/AbsListView.java b/core/java/android/widget/AbsListView.java
index bfd5b5cb74d..3824cb602cd 100644
--- a/core/java/android/widget/AbsListView.java
+++ b/core/java/android/widget/AbsListView.java
@@ -114,6 +114,10 @@ public abstract class AbsListView extends AdapterView<ListAdapter> implements Te
 
     @SuppressWarnings("UnusedDeclaration")
     private static final String TAG = "AbsListView";
+    private static final boolean OPTS_INPUT = true;
+    private static final double MOVE_TOUCH_SLOP = 0.6;
+    private static final double TOUCH_SLOP_MIN = 0.6;
+    private static final double TOUCH_SLOP_MAX = 1.0;
 
     /**
      * Disables the transcript mode.
@@ -779,6 +783,10 @@ public abstract class AbsListView extends AdapterView<ListAdapter> implements Te
      */
     private boolean mIsDetaching;
 
+    private boolean mIsFirstTouchMoveEvent = false;
+    private int mMoveAcceleration;
+    private int mNumTouchMoveEvent = 0;
+
     /**
      * Interface definition for a callback to be invoked when the list or grid
      * has been scrolled.
@@ -922,6 +930,20 @@ public abstract class AbsListView extends AdapterView<ListAdapter> implements Te
         final ViewConfiguration configuration = ViewConfiguration.get(mContext);
         mTouchSlop = configuration.getScaledTouchSlop();
         mVerticalScrollFactor = configuration.getScaledVerticalScrollFactor();
+        if (OPTS_INPUT) {
+            double touchslopprop = MOVE_TOUCH_SLOP;
+            if (touchslopprop > 0) {
+                if (touchslopprop < TOUCH_SLOP_MIN) {
+                    mMoveAcceleration = (int)(mTouchSlop * TOUCH_SLOP_MIN);
+                } else if ((touchslopprop >= TOUCH_SLOP_MIN) && (touchslopprop < TOUCH_SLOP_MAX)){
+                    mMoveAcceleration = (int)(mTouchSlop * touchslopprop);
+                } else {
+                    mMoveAcceleration = mTouchSlop;
+                }
+            } else {
+                mMoveAcceleration = mTouchSlop;
+            }
+        }
         mMinimumVelocity = configuration.getScaledMinimumFlingVelocity();
         mMaximumVelocity = configuration.getScaledMaximumFlingVelocity();
         mOverscrollDistance = configuration.getScaledOverscrollDistance();
@@ -3530,7 +3552,18 @@ public abstract class AbsListView extends AdapterView<ListAdapter> implements Te
         final int deltaY = y - mMotionY;
         final int distance = Math.abs(deltaY);
         final boolean overscroll = mScrollY != 0;
-        if ((overscroll || distance > mTouchSlop) &&
+        boolean isFarEnough = false;
+        if (OPTS_INPUT) {
+            if (mIsFirstTouchMoveEvent) {
+                isFarEnough = distance > mMoveAcceleration;
+            } else {
+                isFarEnough = distance > mTouchSlop;
+            }
+        } else {
+            isFarEnough = distance > mTouchSlop;
+        }
+
+        if ((overscroll || isFarEnough) &&
                 (getNestedScrollAxes() & SCROLL_AXIS_VERTICAL) == 0) {
             createScrollingCache();
             if (overscroll) {
@@ -3538,7 +3571,11 @@ public abstract class AbsListView extends AdapterView<ListAdapter> implements Te
                 mMotionCorrection = 0;
             } else {
                 mTouchMode = TOUCH_MODE_SCROLL;
-                mMotionCorrection = deltaY > 0 ? mTouchSlop : -mTouchSlop;
+                if (mIsFirstTouchMoveEvent) {
+                    mMotionCorrection = deltaY > 0 ? mMoveAcceleration : -mMoveAcceleration;
+                } else {
+                    mMotionCorrection = deltaY > 0 ? mTouchSlop : -mTouchSlop;
+                }
             }
             removeCallbacks(mPendingCheckForLongPress);
             setPressed(false);
@@ -3855,21 +3892,38 @@ public abstract class AbsListView extends AdapterView<ListAdapter> implements Te
         switch (actionMasked) {
             case MotionEvent.ACTION_DOWN: {
                 onTouchDown(ev);
+                if (OPTS_INPUT) {
+                    mNumTouchMoveEvent = 0;
+                }
                 break;
             }
 
             case MotionEvent.ACTION_MOVE: {
+                if (OPTS_INPUT) {
+                    mNumTouchMoveEvent++;
+                    if (mNumTouchMoveEvent == 1) {
+                        mIsFirstTouchMoveEvent = true;
+                    } else {
+                        mIsFirstTouchMoveEvent = false;
+                    }
+                }
                 onTouchMove(ev, vtev);
                 break;
             }
 
             case MotionEvent.ACTION_UP: {
                 onTouchUp(ev);
+                if (OPTS_INPUT) {
+                    mNumTouchMoveEvent = 0;
+                }
                 break;
             }
 
             case MotionEvent.ACTION_CANCEL: {
                 onTouchCancel();
+                if (OPTS_INPUT) {
+                    mNumTouchMoveEvent = 0;
+                }
                 break;
             }
 
@@ -3885,6 +3939,9 @@ public abstract class AbsListView extends AdapterView<ListAdapter> implements Te
                     mMotionPosition = motionPosition;
                 }
                 mLastY = y;
+                if (OPTS_INPUT) {
+                    mNumTouchMoveEvent = 0;
+                }
                 break;
             }
 
@@ -3906,6 +3963,9 @@ public abstract class AbsListView extends AdapterView<ListAdapter> implements Te
                     mMotionPosition = motionPosition;
                 }
                 mLastY = y;
+                if (OPTS_INPUT) {
+                    mNumTouchMoveEvent = 0;
+                }
                 break;
             }
         }
@@ -4490,6 +4550,9 @@ public abstract class AbsListView extends AdapterView<ListAdapter> implements Te
 
         switch (actionMasked) {
         case MotionEvent.ACTION_DOWN: {
+            if (OPTS_INPUT) {
+                mNumTouchMoveEvent = 0;
+            }
             int touchMode = mTouchMode;
             if (touchMode == TOUCH_MODE_OVERFLING || touchMode == TOUCH_MODE_OVERSCROLL) {
                 mMotionCorrection = 0;
@@ -4524,6 +4587,14 @@ public abstract class AbsListView extends AdapterView<ListAdapter> implements Te
         }
 
         case MotionEvent.ACTION_MOVE: {
+            if (OPTS_INPUT) {
+                mNumTouchMoveEvent++;
+                if (mNumTouchMoveEvent == 1) {
+                    mIsFirstTouchMoveEvent = true;
+                } else {
+                    mIsFirstTouchMoveEvent = false;
+                }
+            }
             switch (mTouchMode) {
             case TOUCH_MODE_DOWN:
                 int pointerIndex = ev.findPointerIndex(mActivePointerId);
@@ -4544,6 +4615,9 @@ public abstract class AbsListView extends AdapterView<ListAdapter> implements Te
 
         case MotionEvent.ACTION_CANCEL:
         case MotionEvent.ACTION_UP: {
+            if (OPTS_INPUT) {
+                mNumTouchMoveEvent = 0;
+            }
             mTouchMode = TOUCH_MODE_REST;
             mActivePointerId = INVALID_POINTER;
             recycleVelocityTracker();
@@ -4553,6 +4627,9 @@ public abstract class AbsListView extends AdapterView<ListAdapter> implements Te
         }
 
         case MotionEvent.ACTION_POINTER_UP: {
+            if (OPTS_INPUT) {
+                mNumTouchMoveEvent = 0;
+            }
             onSecondaryPointerUp(ev);
             break;
         }
diff --git a/core/jni/android_view_InputEventReceiver.cpp b/core/jni/android_view_InputEventReceiver.cpp
index 4220c1d8708..f0307caf746 100644
--- a/core/jni/android_view_InputEventReceiver.cpp
+++ b/core/jni/android_view_InputEventReceiver.cpp
@@ -50,6 +50,7 @@ static struct {
     jmethodID dispatchInputEvent;
     jmethodID onFocusEvent;
     jmethodID onBatchedInputEventPending;
+    jmethodID dispatchMotionEventInfo;
 } gInputEventReceiverClassInfo;
 
 
@@ -81,6 +82,8 @@ private:
     bool mBatchedInputEventPending;
     int mFdEvents;
     Vector<Finish> mFinishQueue;
+    int mLastMotionEventType = -1;
+    int mLastTouchMoveNum = -1;
 
     void setFdEvents(int events);
 
@@ -238,10 +241,34 @@ status_t NativeInputEventReceiver::consumeEvents(JNIEnv* env,
     bool skipCallbacks = false;
     for (;;) {
         uint32_t seq;
+        int motionEventType = -1;
+        int touchMoveNum = -1;
+        bool flag = false;
+
         InputEvent* inputEvent;
 
         status_t status = mInputConsumer.consume(&mInputEventFactory,
-                consumeBatches, frameTime, &seq, &inputEvent);
+                consumeBatches, frameTime, &seq, &inputEvent,
+                &motionEventType, &touchMoveNum, &flag);
+
+        if (!receiverObj.get()) {
+            receiverObj.reset(jniGetReferent(env, mReceiverWeakGlobal));
+            if (!receiverObj.get()) {
+                ALOGW("channel '%s' ~ Receiver object was finalized "
+                        "without being disposed.", getInputChannelName().c_str());
+                return DEAD_OBJECT;
+            }
+        }
+
+        if (flag && ((mLastMotionEventType != motionEventType) ||
+               (mLastTouchMoveNum != touchMoveNum))) {
+           env->CallVoidMethod(receiverObj.get(),
+               gInputEventReceiverClassInfo.dispatchMotionEventInfo, motionEventType, touchMoveNum);
+           mLastMotionEventType = motionEventType;
+           mLastTouchMoveNum = touchMoveNum;
+           flag = false;
+        }
+
         if (status != OK && status != WOULD_BLOCK) {
             ALOGE("channel '%s' ~ Failed to consume input event.  status=%d",
                   getInputChannelName().c_str(), status);
@@ -447,7 +474,8 @@ int register_android_view_InputEventReceiver(JNIEnv* env) {
     gInputEventReceiverClassInfo.onBatchedInputEventPending =
             GetMethodIDOrDie(env, gInputEventReceiverClassInfo.clazz, "onBatchedInputEventPending",
                              "(I)V");
-
+    gInputEventReceiverClassInfo.dispatchMotionEventInfo = GetMethodIDOrDie(env,
+            gInputEventReceiverClassInfo.clazz, "dispatchMotionEventInfo", "(II)V");
     return res;
 }
 
-- 
2.17.1

