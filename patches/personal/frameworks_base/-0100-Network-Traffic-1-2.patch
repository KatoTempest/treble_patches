From 265b7f38eae6887b0065e67b1794e56dd6bfae7f Mon Sep 17 00:00:00 2001
From: Victor Bo <bvoid@yandex.ru>
Date: Wed, 25 Nov 2020 08:00:23 -0500
Subject: [PATCH 100/100] Network Traffic [1/2]

  based on https://github.com/ezio84/abc_frameworks_base/commit/589f3585c529fedbd05a6262d2f2e88421604a6a
  https://github.com/ezio84/abc_frameworks_base/commit/7b02691cc014935e3d1966c0d9c575897f66c92f
  https://github.com/ezio84/abc_frameworks_base/commit/cdb899cdb7f6e6d7ba210e58fb97f25a2fbb994e
  https://github.com/ezio84/abc_frameworks_base/commit/acada1276d2dfb7e7f224f73ae14d3a3c3bc0e76
---
 core/java/android/provider/Settings.java      |  11 +
 .../stat_sys_network_traffic_updown.xml       |  26 ++
 packages/SystemUI/res/layout/status_bar.xml   |  12 +-
 .../SystemUI/res/values/custom_dimens.xml     |   3 +
 .../phone/PhoneStatusBarTransitions.java      |   7 +-
 .../statusbar/policy/NetworkTraffic.java      | 308 ++++++++++++++++++
 6 files changed, 364 insertions(+), 3 deletions(-)
 create mode 100644 packages/SystemUI/res/drawable/stat_sys_network_traffic_updown.xml
 create mode 100644 packages/SystemUI/src/com/android/systemui/statusbar/policy/NetworkTraffic.java

diff --git a/core/java/android/provider/Settings.java b/core/java/android/provider/Settings.java
index 6d68e8aa0f4..ac089cadcf7 100755
--- a/core/java/android/provider/Settings.java
+++ b/core/java/android/provider/Settings.java
@@ -4576,6 +4576,17 @@ public final class Settings {
         @UnsupportedAppUsage
         public static final String NOTIFICATION_LIGHT_PULSE = "notification_light_pulse";
 
+        /**
+         * Wheter to show network traffic indicator in statusbar
+         * @hide
+         */
+        public static final String NETWORK_TRAFFIC_STATE = "network_traffic_state";
+         /**
+         * Network traffic inactivity threshold (default is 1 kBs)
+         * @hide
+         */
+        public static final String NETWORK_TRAFFIC_AUTOHIDE_THRESHOLD = "network_traffic_autohide_threshold";
+
         /**
          * Show pointer location on screen?
          * 0 = no
diff --git a/packages/SystemUI/res/drawable/stat_sys_network_traffic_updown.xml b/packages/SystemUI/res/drawable/stat_sys_network_traffic_updown.xml
new file mode 100644
index 00000000000..b6fc1288ee2
--- /dev/null
+++ b/packages/SystemUI/res/drawable/stat_sys_network_traffic_updown.xml
@@ -0,0 +1,26 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (C) 2017 The Android Open Source Project
+    Copyright (C) 2017 ABC rom
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+        http://www.apache.org/licenses/LICENSE-2.0
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+        android:width="5dp"
+        android:height="17.0dp"
+        android:viewportWidth="7.1"
+        android:viewportHeight="24.0">
+    <path
+        android:fillColor="#ffffff"
+        android:pathData="M3.6000004,10.8l3.5,0.0 -3.5,-7.3 0.0,0.0 0.0,0.0 0.0,0.0 0.0,0.0 -3.6,7.3z"/>
+    <path
+        android:fillColor="#ffffff"
+        android:pathData="M3.6000004,13.2l-3.6,0.0 3.6,7.3 0.0,0.0 0.0,0.0 0.0,0.0 0.0,0.0 3.5,-7.3z"/>
+</vector>
diff --git a/packages/SystemUI/res/layout/status_bar.xml b/packages/SystemUI/res/layout/status_bar.xml
index f8db97dbf80..d42e845f85d 100644
--- a/packages/SystemUI/res/layout/status_bar.xml
+++ b/packages/SystemUI/res/layout/status_bar.xml
@@ -110,13 +110,23 @@
             android:gravity="center_horizontal|center_vertical"/>
 
         <com.android.keyguard.AlphaOptimizedLinearLayout android:id="@+id/system_icon_area"
-            android:layout_width="0dp"
+            android:layout_width="wrap_content"
             android:layout_height="match_parent"
             android:layout_weight="1"
             android:orientation="horizontal"
             android:gravity="center_vertical|end"
             >
 
+        <com.android.systemui.statusbar.policy.NetworkTraffic
+            android:id="@+id/networkTraffic"
+            android:layout_width="wrap_content"
+            android:layout_height="match_parent"
+            android:layout_marginStart="1dp"
+            android:layout_marginEnd="1dp"
+            android:singleLine="false"
+            android:fontFamily="sans-serif-condensed"
+            android:gravity="right|center_vertical"/>
+
             <include layout="@layout/system_icons" />
         </com.android.keyguard.AlphaOptimizedLinearLayout>
     </LinearLayout>
diff --git a/packages/SystemUI/res/values/custom_dimens.xml b/packages/SystemUI/res/values/custom_dimens.xml
index ad24ef26d42..132c83fb3c4 100644
--- a/packages/SystemUI/res/values/custom_dimens.xml
+++ b/packages/SystemUI/res/values/custom_dimens.xml
@@ -17,4 +17,7 @@
 -->
 <resources>
     <dimen name="screenrecord_dot_size">48dp</dimen>
+    <!-- Network traffic monitor -->
+    <dimen name="net_traffic_multi_text_size">8dp</dimen>
+    <dimen name="net_traffic_txt_img_padding">2dp</dimen>
 </resources>
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBarTransitions.java b/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBarTransitions.java
index 2052ee6cdac..bdf05ada650 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBarTransitions.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBarTransitions.java
@@ -31,7 +31,7 @@ public final class PhoneStatusBarTransitions extends BarTransitions {
 
     private final float mIconAlphaWhenOpaque;
 
-    private View mLeftSide, mStatusIcons, mBattery;
+    private View mLeftSide, mStatusIcons, mBattery, mNetworkTraffic;
     private Animator mCurrentAnimation;
 
     /**
@@ -44,6 +44,7 @@ public final class PhoneStatusBarTransitions extends BarTransitions {
         mLeftSide = statusBarView.findViewById(R.id.status_bar_left_side);
         mStatusIcons = statusBarView.findViewById(R.id.statusIcons);
         mBattery = statusBarView.findViewById(R.id.battery);
+        mNetworkTraffic = statusBarView.findViewById(R.id.networkTraffic);
         applyModeBackground(-1, getMode(), false /*animate*/);
         applyMode(getMode(), false /*animate*/);
     }
@@ -86,7 +87,8 @@ public final class PhoneStatusBarTransitions extends BarTransitions {
             anims.playTogether(
                     animateTransitionTo(mLeftSide, newAlpha),
                     animateTransitionTo(mStatusIcons, newAlpha),
-                    animateTransitionTo(mBattery, newAlphaBC)
+                    animateTransitionTo(mBattery, newAlphaBC),
+                    animateTransitionTo(mNetworkTraffic, newAlpha)
                     );
             if (isLightsOut(mode)) {
                 anims.setDuration(LIGHTS_OUT_DURATION);
@@ -97,6 +99,7 @@ public final class PhoneStatusBarTransitions extends BarTransitions {
             mLeftSide.setAlpha(newAlpha);
             mStatusIcons.setAlpha(newAlpha);
             mBattery.setAlpha(newAlphaBC);
+            mNetworkTraffic.setAlpha(newAlpha);
         }
     }
 }
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/policy/NetworkTraffic.java b/packages/SystemUI/src/com/android/systemui/statusbar/policy/NetworkTraffic.java
new file mode 100644
index 00000000000..b2220d84dcb
--- /dev/null
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/policy/NetworkTraffic.java
@@ -0,0 +1,308 @@
+package com.android.systemui.statusbar.policy;
+
+import java.text.DecimalFormat;
+
+import android.content.BroadcastReceiver;
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.res.Resources;
+import android.database.ContentObserver;
+import android.graphics.drawable.Drawable;
+import android.graphics.PorterDuff.Mode;
+import android.graphics.Rect;
+import android.net.ConnectivityManager;
+import android.net.NetworkInfo;
+import android.net.TrafficStats;
+import android.net.Uri;
+import android.os.Handler;
+import android.os.UserHandle;
+import android.os.Message;
+import android.os.SystemClock;
+import android.provider.Settings;
+import android.util.AttributeSet;
+import android.util.TypedValue;
+import android.view.View;
+import android.widget.TextView;
+
+import com.android.systemui.Dependency;
+import com.android.systemui.R;
+import com.android.systemui.plugins.DarkIconDispatcher.DarkReceiver;
+/*
+*
+* Seeing how an Integer object in java requires at least 16 Bytes, it seemed awfully wasteful
+* to only use it for a single boolean. 32-bits is plenty of room for what we need it to do.
+*
+*/
+public class NetworkTraffic extends TextView implements DarkReceiver {
+
+    private static final int INTERVAL = 1500; //ms
+    private static final int KB = 1024;
+    private static final int MB = KB * KB;
+    private static final int GB = MB * KB;
+    private static final String symbol = "B/s";
+
+    private static DecimalFormat decimalFormat = new DecimalFormat("##0.#");
+    static {
+        decimalFormat.setMaximumIntegerDigits(3);
+        decimalFormat.setMaximumFractionDigits(1);
+    }
+
+    private boolean mIsEnabled;
+    private boolean mAttached;
+    private long totalRxBytes;
+    private long totalTxBytes;
+    private long lastUpdateTime;
+    private int txtSize;
+    private int txtImgPadding;
+    private int mAutoHideThreshold = 1;
+    private int mTintColor;
+
+    private boolean mScreenOn = true;
+
+    private Handler mTrafficHandler = new Handler() {
+        @Override
+        public void handleMessage(Message msg) {
+            long timeDelta = SystemClock.elapsedRealtime() - lastUpdateTime;
+
+            if (timeDelta < INTERVAL * .95) {
+                if (msg.what != 1) {
+                    // we just updated the view, nothing further to do
+                    return;
+                }
+                if (timeDelta < 1) {
+                    // Can't div by 0 so make sure the value displayed is minimal
+                    timeDelta = Long.MAX_VALUE;
+                }
+            }
+            lastUpdateTime = SystemClock.elapsedRealtime();
+
+            // Calculate the data rate from the change in total bytes and time
+            long newTotalRxBytes = TrafficStats.getTotalRxBytes();
+            long newTotalTxBytes = TrafficStats.getTotalTxBytes();
+            long rxData = newTotalRxBytes - totalRxBytes;
+            long txData = newTotalTxBytes - totalTxBytes;
+
+            if (shouldHide(rxData, txData, timeDelta)) {
+                setText("");
+                setVisibility(View.GONE);
+            } else {
+                // Get information for uplink ready so the line return can be added
+                String output = formatOutput(timeDelta, txData, symbol);
+                // Ensure text size is where it needs to be
+                output += "\n";
+                // Add information for downlink if it's called for
+                output += formatOutput(timeDelta, rxData, symbol);
+
+                // Update view if there's anything new to show
+                if (! output.contentEquals(getText())) {
+                    setTextSize(TypedValue.COMPLEX_UNIT_PX, (float)txtSize);
+                    setText(output);
+                }
+                setVisibility(View.VISIBLE);
+            }
+
+            // Post delayed message to refresh in ~1000ms
+            totalRxBytes = newTotalRxBytes;
+            totalTxBytes = newTotalTxBytes;
+            clearHandlerCallbacks();
+            mTrafficHandler.postDelayed(mRunnable, INTERVAL);
+        }
+
+        private String formatOutput(long timeDelta, long data, String symbol) {
+            long speed = (long)(data / (timeDelta / 1000F));
+            if (speed < KB) {
+                return decimalFormat.format(speed) + symbol;
+            } else if (speed < MB) {
+                return decimalFormat.format(speed / (float)KB) + 'K' + symbol;
+            } else if (speed < GB) {
+                return decimalFormat.format(speed / (float)MB) + 'M' + symbol;
+            }
+            return decimalFormat.format(speed / (float)GB) + 'G' + symbol;
+        }
+
+        private boolean shouldHide(long rxData, long txData, long timeDelta) {
+            long speedTxKB = (long)(txData / (timeDelta / 1000f)) / KB;
+            long speedRxKB = (long)(rxData / (timeDelta / 1000f)) / KB;
+            return !getConnectAvailable() ||
+                    (speedRxKB < mAutoHideThreshold &&
+                    speedTxKB < mAutoHideThreshold);
+        }
+    };
+
+    private Runnable mRunnable = new Runnable() {
+        @Override
+        public void run() {
+            mTrafficHandler.sendEmptyMessage(0);
+        }
+    };
+
+    class SettingsObserver extends ContentObserver {
+        SettingsObserver(Handler handler) {
+            super(handler);
+        }
+
+        void observe() {
+            ContentResolver resolver = mContext.getContentResolver();
+            resolver.registerContentObserver(Settings.System
+                    .getUriFor(Settings.System.NETWORK_TRAFFIC_STATE), false,
+                    this, UserHandle.USER_ALL);
+            //resolver.registerContentObserver(Settings.System
+            //        .getUriFor(Settings.System.NETWORK_TRAFFIC_AUTOHIDE_THRESHOLD), false,
+            //        this, UserHandle.USER_ALL);
+        }
+
+        /*
+         *  @hide
+         */
+        @Override
+        public void onChange(boolean selfChange) {
+            setMode();
+            updateSettings();
+        }
+    }
+
+    /*
+     *  @hide
+     */
+    public NetworkTraffic(Context context) {
+        this(context, null);
+    }
+
+    /*
+     *  @hide
+     */
+    public NetworkTraffic(Context context, AttributeSet attrs) {
+        this(context, attrs, 0);
+    }
+
+    /*
+     *  @hide
+     */
+    public NetworkTraffic(Context context, AttributeSet attrs, int defStyle) {
+        super(context, attrs, defStyle);
+        final Resources resources = getResources();
+        txtSize = resources.getDimensionPixelSize(R.dimen.net_traffic_multi_text_size);
+        txtImgPadding = resources.getDimensionPixelSize(R.dimen.net_traffic_txt_img_padding);
+        mTintColor = resources.getColor(android.R.color.white);
+        Handler mHandler = new Handler();
+        SettingsObserver settingsObserver = new SettingsObserver(mHandler);
+        settingsObserver.observe();
+        setMode();
+        updateSettings();
+    }
+
+    @Override
+    protected void onAttachedToWindow() {
+        super.onAttachedToWindow();
+        if (!mAttached) {
+            mAttached = true;
+            IntentFilter filter = new IntentFilter();
+            filter.addAction(ConnectivityManager.CONNECTIVITY_ACTION);
+            filter.addAction(Intent.ACTION_SCREEN_OFF);
+            filter.addAction(Intent.ACTION_SCREEN_ON);
+            mContext.registerReceiver(mIntentReceiver, filter, null, getHandler());
+        }
+        Dependency.get(DarkIconDispatcher.class).addDarkReceiver(this);
+        updateSettings();
+    }
+
+    @Override
+    protected void onDetachedFromWindow() {
+        super.onDetachedFromWindow();
+        if (mAttached) {
+            mContext.unregisterReceiver(mIntentReceiver);
+            mAttached = false;
+        }
+        Dependency.get(DarkIconDispatcher.class).removeDarkReceiver(this);
+    }
+
+    private final BroadcastReceiver mIntentReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            String action = intent.getAction();
+            if (action == null) return;
+
+            if (action.equals(ConnectivityManager.CONNECTIVITY_ACTION) && mScreenOn) {
+                updateSettings();
+            } else if (action.equals(Intent.ACTION_SCREEN_ON)) {
+                mScreenOn = true;
+                updateSettings();
+            } else if (action.equals(Intent.ACTION_SCREEN_OFF)) {
+                mScreenOn = false;
+                clearHandlerCallbacks();
+            }
+        }
+    };
+
+    private boolean getConnectAvailable() {
+        ConnectivityManager connManager =
+                (ConnectivityManager) mContext.getSystemService(Context.CONNECTIVITY_SERVICE);
+        NetworkInfo network = (connManager != null) ? connManager.getActiveNetworkInfo() : null;
+        return network != null;
+    }
+
+    private void updateSettings() {
+        if (mIsEnabled) {
+            if (mAttached) {
+                totalRxBytes = TrafficStats.getTotalRxBytes();
+                lastUpdateTime = SystemClock.elapsedRealtime();
+                mTrafficHandler.sendEmptyMessage(1);
+            }
+            updateTrafficDrawable();
+            return;
+        } else {
+            clearHandlerCallbacks();
+        }
+        setVisibility(View.GONE);
+    }
+
+    private void setMode() {
+        ContentResolver resolver = mContext.getContentResolver();
+        mIsEnabled = Settings.System.getIntForUser(resolver,
+                Settings.System.NETWORK_TRAFFIC_STATE, 1,
+                UserHandle.USER_CURRENT) == 1;
+        //mAutoHideThreshold = Settings.System.getIntForUser(resolver,
+        //        Settings.System.NETWORK_TRAFFIC_AUTOHIDE_THRESHOLD, 1,
+        //        UserHandle.USER_CURRENT);
+    }
+
+    private void clearHandlerCallbacks() {
+        mTrafficHandler.removeCallbacks(mRunnable);
+        mTrafficHandler.removeMessages(0);
+        mTrafficHandler.removeMessages(1);
+    }
+
+    private void updateTrafficDrawable() {
+        int intTrafficDrawable;
+        if (mIsEnabled) {
+            intTrafficDrawable = R.drawable.stat_sys_network_traffic_updown;
+        } else {
+            intTrafficDrawable = 0;
+        }
+        if (intTrafficDrawable != 0) {
+            Drawable d = getContext().getDrawable(intTrafficDrawable);
+            d.setColorFilter(mTintColor, Mode.SRC_ATOP);
+            setCompoundDrawablePadding(txtImgPadding);
+            setCompoundDrawablesWithIntrinsicBounds(null, null, d, null);
+        } else {
+            setCompoundDrawablesWithIntrinsicBounds(0, 0, 0, 0);
+        }
+    }
+
+    public void onDensityOrFontScaleChanged() {
+        final Resources resources = getResources();
+        txtSize = resources.getDimensionPixelSize(R.dimen.net_traffic_multi_text_size);
+        txtImgPadding = resources.getDimensionPixelSize(R.dimen.net_traffic_multi_text_size);
+        setTextSize(TypedValue.COMPLEX_UNIT_PX, (float)txtSize);
+        setCompoundDrawablePadding(txtImgPadding);
+    }
+
+    @Override
+    public void onDarkChanged(Rect area, float darkIntensity, int tint) {
+        mTintColor = DarkIconDispatcher.getTint(area, this, tint);
+        setTextColor(mTintColor);
+        updateTrafficDrawable();
+    }
+}
-- 
2.17.1

