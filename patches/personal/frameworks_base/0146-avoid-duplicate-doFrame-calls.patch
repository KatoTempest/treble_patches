From 165be96efa36aeb59df4948576257398c5b95a87 Mon Sep 17 00:00:00 2001
From: Victor Bo <bvoid@yandex.ru>
Date: Wed, 16 Dec 2020 15:01:09 -0500
Subject: [PATCH 146/193] avoid duplicate doFrame calls

  from
  https://github.com/syberia-project/platform_frameworks_base/commit/d8c850656cd4a6f274080db274a7a1abf09e2352
---
 core/java/android/view/Choreographer.java | 15 ++++++++++-----
 1 file changed, 10 insertions(+), 5 deletions(-)

diff --git a/core/java/android/view/Choreographer.java b/core/java/android/view/Choreographer.java
index 5a92c7497c1..d10d571b312 100644
--- a/core/java/android/view/Choreographer.java
+++ b/core/java/android/view/Choreographer.java
@@ -193,6 +193,7 @@ public final class Choreographer {
     private boolean mConsumedDown = false;
     private boolean mIsVsyncScheduled = false;
     private long mLastTouchOptTimeNanos = 0;
+    private boolean mIsDoFrameProcessing = false;
     /**
      * Contains information about the current frame for jank-tracking,
      * mainly timings of key events along with a bit of metadata about
@@ -652,16 +653,18 @@ public final class Choreographer {
                     long curr = System.nanoTime();
                     boolean skipFlag = curr - mLastTouchOptTimeNanos < mFrameIntervalNanos;
                     Trace.traceBegin(Trace.TRACE_TAG_VIEW, "scheduleFrameLocked-mMotionEventType:"
-                                     + mMotionEventType + " mTouchMoveNum:" + mTouchMoveNum
-                                     + " mConsumedDown:" + mConsumedDown + " mConsumedMove:"
-                                     + mConsumedMove + " skip:" + skipFlag
+                                     + mMotionEventType + " mTouchMoveNum:"+ mTouchMoveNum 
+                                     + " mConsumedDown:" + mConsumedDown
+                                     + " mConsumedMove:" + mConsumedMove
+                                     + " mIsDoFrameProcessing:" + mIsDoFrameProcessing
+                                     + " skip:" + skipFlag 
                                      + " diff:" + (curr - mLastTouchOptTimeNanos));
                     Trace.traceEnd(Trace.TRACE_TAG_VIEW);
                     synchronized(this) {
                         switch(mMotionEventType) {
                             case MOTION_EVENT_ACTION_DOWN:
                                 mConsumedMove = false;
-                                if (!mConsumedDown && !skipFlag) {
+                                if (!mConsumedDown && !skipFlag && !mIsDoFrameProcessing) {
                                     Message msg = mHandler.obtainMessage(MSG_DO_FRAME);
                                     msg.setAsynchronous(true);
                                     mHandler.sendMessageAtFrontOfQueue(msg);
@@ -673,7 +676,7 @@ public final class Choreographer {
                             case MOTION_EVENT_ACTION_MOVE:
                                 mConsumedDown = false;
                                 //if ((mTouchMoveNum == 1) && !mConsumedMove && !skipFlag) {
-                                if (!mConsumedMove && !skipFlag) {
+                                if (!mConsumedMove && !skipFlag && !mIsDoFrameProcessing) {
                                     Message msg = mHandler.obtainMessage(MSG_DO_FRAME);
                                     msg.setAsynchronous(true);
                                     mHandler.sendMessageAtFrontOfQueue(msg);
@@ -785,6 +788,7 @@ public final class Choreographer {
         }
 
         try {
+            mIsDoFrameProcessing = true;
             Trace.traceBegin(Trace.TRACE_TAG_VIEW, "Choreographer#doFrame");
             AnimationUtils.lockAnimationClock(frameTimeNanos / TimeUtils.NANOS_PER_MS);
 
@@ -810,6 +814,7 @@ public final class Choreographer {
                     + (endNanos - startNanos) * 0.000001f + " ms, latency "
                     + (startNanos - frameTimeNanos) * 0.000001f + " ms.");
         }
+        mIsDoFrameProcessing = false;
     }
 
     void doCallbacks(int callbackType, long frameTimeNanos) {
-- 
2.17.1

