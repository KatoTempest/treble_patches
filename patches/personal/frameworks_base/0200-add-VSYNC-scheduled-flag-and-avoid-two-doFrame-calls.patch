From 93961195bf052ffbd0b9b0df7bf4d835076bb291 Mon Sep 17 00:00:00 2001
From: Victor Bo <bvoid@yandex.ru>
Date: Wed, 16 Dec 2020 14:55:54 -0500
Subject: [PATCH 200/211] add VSYNC scheduled flag and avoid two doFrame calls
 in one period

  from
  https://github.com/syberia-project/platform_frameworks_base/commit/368eb42d319aa70346806670ca8457961263dea4
---
 core/java/android/view/Choreographer.java | 72 +++++++++++++----------
 1 file changed, 40 insertions(+), 32 deletions(-)

diff --git a/core/java/android/view/Choreographer.java b/core/java/android/view/Choreographer.java
index 3038454f1f0..ecd8f90d03f 100644
--- a/core/java/android/view/Choreographer.java
+++ b/core/java/android/view/Choreographer.java
@@ -191,6 +191,7 @@ public final class Choreographer {
     private int mMotionEventType = -1;
     private boolean mConsumedMove = false;
     private boolean mConsumedDown = false;
+    private boolean mIsVsyncScheduled = false;
     /**
      * Contains information about the current frame for jank-tracking,
      * mainly timings of key events along with a bit of metadata about
@@ -646,38 +647,43 @@ public final class Choreographer {
         if (!mFrameScheduled) {
             mFrameScheduled = true;
             if (OPTS_INPUT) {
-                Trace.traceBegin(Trace.TRACE_TAG_VIEW, "scheduleFrameLocked-mMotionEventType:" + mMotionEventType + " mTouchMoveNum:" + mTouchMoveNum
-                                    + " mConsumedDown:" + mConsumedDown + " mConsumedMove:" + mConsumedMove);
-                Trace.traceEnd(Trace.TRACE_TAG_VIEW);
-                synchronized(this) {
-                    switch(mMotionEventType) {
-                        case MOTION_EVENT_ACTION_DOWN:
-                            mConsumedMove = false;
-                            if (!mConsumedDown) {
-                                Message msg = mHandler.obtainMessage(MSG_DO_FRAME);
-                                msg.setAsynchronous(true);
-                                mHandler.sendMessageAtFrontOfQueue(msg);
-                                mConsumedDown = true;
-                                return;
-                            }
-                            break;
-                        case MOTION_EVENT_ACTION_MOVE:
-                            mConsumedDown = false;
-                            if ((mTouchMoveNum == 1) && !mConsumedMove) {
-                                Message msg = mHandler.obtainMessage(MSG_DO_FRAME);
-                                msg.setAsynchronous(true);
-                                mHandler.sendMessageAtFrontOfQueue(msg);
-                                mConsumedMove = true;
-                                return;
-                            }
-                            break;
-                        case MOTION_EVENT_ACTION_UP:
-                        case MOTION_EVENT_ACTION_CANCEL:
-                            mConsumedMove = false;
-                            mConsumedDown = false;
-                            break;
-                        default:
-                            break;
+                if ((!mIsVsyncScheduled) &&
+                    ((System.nanoTime() - mLastFrameTimeNanos) > mFrameIntervalNanos)) {
+                    Trace.traceBegin(Trace.TRACE_TAG_VIEW, "scheduleFrameLocked-mMotionEventType:"
+                                     + mMotionEventType + " mTouchMoveNum:" + mTouchMoveNum
+                                     + " mConsumedDown:" + mConsumedDown + " mConsumedMove:"
+                                     + mConsumedMove);
+                    Trace.traceEnd(Trace.TRACE_TAG_VIEW);
+                    synchronized(this) {
+                        switch(mMotionEventType) {
+                            case MOTION_EVENT_ACTION_DOWN:
+                                mConsumedMove = false;
+                                if (!mConsumedDown) {
+                                    Message msg = mHandler.obtainMessage(MSG_DO_FRAME);
+                                    msg.setAsynchronous(true);
+                                    mHandler.sendMessageAtFrontOfQueue(msg);
+                                    mConsumedDown = true;
+                                    return;
+                                }
+                                break;
+                            case MOTION_EVENT_ACTION_MOVE:
+                                mConsumedDown = false;
+                                if ((mTouchMoveNum == 1) && !mConsumedMove) {
+                                    Message msg = mHandler.obtainMessage(MSG_DO_FRAME);
+                                    msg.setAsynchronous(true);
+                                    mHandler.sendMessageAtFrontOfQueue(msg);
+                                    mConsumedMove = true;
+                                    return;
+                                }
+                                break;
+                            case MOTION_EVENT_ACTION_UP:
+                            case MOTION_EVENT_ACTION_CANCEL:
+                                mConsumedMove = false;
+                                mConsumedDown = false;
+                                break;
+                            default:
+                                break;
+                        }
                     }
                 }
             }
@@ -719,6 +725,7 @@ public final class Choreographer {
     void doFrame(long frameTimeNanos, int frame) {
         final long startNanos;
         synchronized (mLock) {
+            mIsVsyncScheduled = false;
             if (!mFrameScheduled) {
                 return; // no work to do
             }
@@ -885,6 +892,7 @@ public final class Choreographer {
     @UnsupportedAppUsage
     private void scheduleVsyncLocked() {
         mDisplayEventReceiver.scheduleVsync();
+        mIsVsyncScheduled = true;
     }
 
     private boolean isRunningOnLooperThreadLocked() {
-- 
2.17.1

