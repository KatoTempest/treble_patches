From ffa3a21f6325566de6ef713c527ffa65f7f92217 Mon Sep 17 00:00:00 2001
From: Uldiniad <olivercscott@gmail.com>
Date: Thu, 1 Mar 2018 08:54:00 -0500
Subject: [PATCH 1/2] system/netd: Squash of app fw restriction commits

Author: Uldiniad <olivercscott@gmail.com>
Date:   Thu Mar 1 08:54:00 2018 -0500

    [3/3] NetD : Allow passing in interface names for wifi/data app restriction

    CYAN-3976
    CRACKLING-834

    This is a simplification and adpatation for oreo of:
    https://review.lineageos.org/#/c/LineageOS/android_system_netd/+/144246/
    by wangjing <wangjing@codeaurora.org>

    Change-Id: I085434d70dfe00e9c27b821661fff5076d57e930

----

Author: Uldiniad <olivercscott@gmail.com>
Date:   Tue Oct 30 23:59:08 2018 +0000

    NetD : Allow passing in interface names for vpn app restriction

    Change-Id: I7cb0c895db60dcf6b4fe59732ec6c0ec3c212a04

----

Author: Sam Mortimer <sam@mortimer.me.uk>
Date:   Thu Aug 29 16:48:55 2019 -0700

    netd: Consolidate restrict apps methods

    * These are lineage additions (that originated
      from caf).

    * addRestrictAppsOnData, addRestrictAppsOnVpn and
      addRestrictAppsOnWlan all do a similar thing
      (fw/b passes different interface arguments).

    * Consolidate into addRestrictAppsOnInterface
      (and removeRestrictAppsOnInterface)

    * Requires corresponding fw/b services change.

    Change-Id: Ic780e943583e616c137c42aa4a72f7af63d02dce

----

Author: Sam Mortimer <sam@mortimer.me.uk>
Date: Fri Apr 10 19:19:47 2020 -0400

    system/netd: Add BPF support for lineage network restrictions

    Required for kernels 4.9+

    Change-Id: I369c95b33742f8b3f95764ab43fbfb20dd4ec0e5

Change-Id: Ieaa34e922dcbe3bd7b293781b0f56e0eb02b7606
---
 bpf_progs/netd.c                              |  11 ++
 libnetdbpf/include/netdbpf/bpf_shared.h       |   7 +
 server/Android.bp                             |   1 +
 server/BandwidthController.cpp                | 112 ++++++++++++
 server/BandwidthController.h                  |  14 ++
 server/NetdNativeService.cpp                  |  16 ++
 server/NetdNativeService.h                    |   6 +
 server/TrafficController.cpp                  |  96 +++++++++-
 server/TrafficController.h                    |  13 +-
 server/aidl_api/netd_aidl_interface/5/.hash   |   1 +
 .../5/android/net/INetd.aidl                  | 166 ++++++++++++++++++
 .../net/INetdUnsolicitedEventListener.aidl    |  32 ++++
 .../net/InterfaceConfigurationParcel.aidl     |  26 +++
 .../5/android/net/MarkMaskParcel.aidl         |  23 +++
 .../5/android/net/RouteInfoParcel.aidl        |  24 +++
 .../5/android/net/TetherConfigParcel.aidl     |  23 +++
 .../android/net/TetherOffloadRuleParcel.aidl  |  28 +++
 .../5/android/net/TetherStatsParcel.aidl      |  27 +++
 .../5/android/net/UidRangeParcel.aidl         |  23 +++
 .../current/android/net/INetd.aidl            |   2 +
 server/binder/android/net/INetd.aidl          |  23 +++
 21 files changed, 663 insertions(+), 11 deletions(-)
 create mode 100644 server/aidl_api/netd_aidl_interface/5/.hash
 create mode 100644 server/aidl_api/netd_aidl_interface/5/android/net/INetd.aidl
 create mode 100644 server/aidl_api/netd_aidl_interface/5/android/net/INetdUnsolicitedEventListener.aidl
 create mode 100644 server/aidl_api/netd_aidl_interface/5/android/net/InterfaceConfigurationParcel.aidl
 create mode 100644 server/aidl_api/netd_aidl_interface/5/android/net/MarkMaskParcel.aidl
 create mode 100644 server/aidl_api/netd_aidl_interface/5/android/net/RouteInfoParcel.aidl
 create mode 100644 server/aidl_api/netd_aidl_interface/5/android/net/TetherConfigParcel.aidl
 create mode 100644 server/aidl_api/netd_aidl_interface/5/android/net/TetherOffloadRuleParcel.aidl
 create mode 100644 server/aidl_api/netd_aidl_interface/5/android/net/TetherStatsParcel.aidl
 create mode 100644 server/aidl_api/netd_aidl_interface/5/android/net/UidRangeParcel.aidl

diff --git a/bpf_progs/netd.c b/bpf_progs/netd.c
index f3470280..642110a9 100644
--- a/bpf_progs/netd.c
+++ b/bpf_progs/netd.c
@@ -192,6 +192,9 @@ static inline int bpf_owner_match(struct __sk_buff* skb, uint32_t uid, int direc
     UidOwnerValue* uidEntry = bpf_uid_owner_map_lookup_elem(&uid);
     uint8_t uidRules = uidEntry ? uidEntry->rule : 0;
     uint32_t allowed_iif = uidEntry ? uidEntry->iif : 0;
+    uint32_t blacklisted_if[3] = { uidEntry ? uidEntry->if_blacklist[0] : 0,
+                                   uidEntry ? uidEntry->if_blacklist[1] : 0,
+                                   uidEntry ? uidEntry->if_blacklist[2] : 0 };
 
     if (enabledRules) {
         if ((enabledRules & DOZABLE_MATCH) && !(uidRules & DOZABLE_MATCH)) {
@@ -210,6 +213,14 @@ static inline int bpf_owner_match(struct __sk_buff* skb, uint32_t uid, int direc
             return BPF_DROP_UNLESS_DNS;
         }
     }
+    if (uidRules & IF_BLACKLIST) {
+        // Drops packets arriving or leaving via any blacklisted interface.
+        for (int i = 0; i < UID_MAX_IF_BLACKLIST; i++) {
+            if (blacklisted_if[i] && skb->ifindex == blacklisted_if[i]) {
+                return BPF_DROP;
+            }
+        }
+    }
     return BPF_PASS;
 }
 
diff --git a/libnetdbpf/include/netdbpf/bpf_shared.h b/libnetdbpf/include/netdbpf/bpf_shared.h
index 6f318799..022c3786 100644
--- a/libnetdbpf/include/netdbpf/bpf_shared.h
+++ b/libnetdbpf/include/netdbpf/bpf_shared.h
@@ -118,6 +118,7 @@ enum UidOwnerMatchType {
     STANDBY_MATCH = (1 << 3),
     POWERSAVE_MATCH = (1 << 4),
     IIF_MATCH = (1 << 5),
+    IF_BLACKLIST = (1 << 6),
 };
 
 enum BpfPermissionMatch {
@@ -137,9 +138,15 @@ enum StatsMapType {
 typedef uint8_t BpfConfig;
 const BpfConfig DEFAULT_CONFIG = 0;
 
+// Size of interface blacklist (per uid).
+#define UID_MAX_IF_BLACKLIST 3
+
 typedef struct {
     // Allowed interface index. Only applicable if IIF_MATCH is set in the rule bitmask above.
     uint32_t iif;
+    // Denied in/out interface indexes. Only applicable if IF_BLACKLIST is set in the
+    // rule bitmask above.
+    uint32_t if_blacklist[UID_MAX_IF_BLACKLIST];
     // A bitmask of enum values in UidOwnerMatchType.
     uint8_t rule;
 } UidOwnerValue;
diff --git a/server/Android.bp b/server/Android.bp
index aa932c22..2aaface8 100644
--- a/server/Android.bp
+++ b/server/Android.bp
@@ -33,6 +33,7 @@ aidl_interface {
         "2",
         "3",
         "4",
+        "5",
     ],
 }
 
diff --git a/server/BandwidthController.cpp b/server/BandwidthController.cpp
index e1ce56f2..a5b65d42 100644
--- a/server/BandwidthController.cpp
+++ b/server/BandwidthController.cpp
@@ -55,6 +55,7 @@
 #include "FirewallController.h" /* For makeCriticalCommands */
 #include "Fwmark.h"
 #include "NetdConstants.h"
+#include "RouteController.h"
 #include "TrafficController.h"
 #include "bpf/BpfUtils.h"
 
@@ -86,6 +87,11 @@ const std::string NEW_CHAIN_COMMAND = "-N ";
 const char NAUGHTY_CHAIN[] = "bw_penalty_box";
 const char NICE_CHAIN[] = "bw_happy_box";
 
+// Must match RESTRICT_USECASE_* definitions in
+// frameworks/base/services/core/java/com/android/server/NetworkManagementService.java
+const std::array<std::string, UID_MAX_IF_BLACKLIST> APP_RESTRICT_USE_CASES =
+        { "data", "vpn", "wlan" };
+
 /**
  * Some comments about the rules:
  *  * Ordering
@@ -319,6 +325,8 @@ int BandwidthController::enableBandwidthControl() {
     mGlobalAlertBytes = 0;
     mSharedQuotaBytes = mSharedAlertBytes = 0;
 
+    mRestrictAppsOnInterface.clear();
+
     flushCleanTables(false);
 
     std::string commands = Join(getBasicAccountingCommands(mBpfSupported), '\n');
@@ -392,6 +400,110 @@ int BandwidthController::removeNiceApps(const std::vector<std::string>& appStrUi
     return manipulateSpecialApps(appStrUid, NICE_CHAIN, IptJumpReturn, IptOpDelete);
 }
 
+int BandwidthController::addRestrictAppsOnInterface(const std::string& usecase,
+                                                    const std::string& iface,
+                                                    const std::vector<std::string>& appStrUid) {
+    return manipulateRestrictAppsInOut(usecase, iface, appStrUid, IptOpInsert);
+}
+
+int BandwidthController::removeRestrictAppsOnInterface(const std::string& usecase,
+                                                    const std::string& iface,
+                                                    const std::vector<std::string>& appStrUid) {
+    return manipulateRestrictAppsInOut(usecase, iface, appStrUid, IptOpDelete);
+}
+
+
+int BandwidthController::appsOnInterfaceAccounting(const std::string& usecase,
+                                                   const std::vector<std::string>& appStrUids,
+                                                   IptOp op, bool update) {
+    /* Keep separate per app uid vectors for each usecase (vpn, wlan etc) */
+    std::vector<int>& restrictAppUids = mRestrictAppsOnInterface[usecase];
+
+    // Check our local per uid restriction accounting and update if requested.
+    for (const auto& appStrUid : appStrUids) {
+        int uid = std::stoi(appStrUid, nullptr, 0);
+        auto it = std::find(restrictAppUids.begin(), restrictAppUids.end(), uid);
+        bool found = (it != restrictAppUids.end());
+        if (op == IptOpDelete) {
+            if (!found) {
+                ALOGE("No such appUid %d to remove", uid);
+                return -1;
+            }
+            if (update) {
+                restrictAppUids.erase(it);
+            }
+        } else {
+            if (found) {
+                ALOGE("appUid %d exists already", uid);
+                return -1;
+            }
+            if (update) {
+                restrictAppUids.push_back(uid);
+            }
+        }
+    }
+    return 0;
+}
+
+int BandwidthController::manipulateRestrictAppsInOut(const std::string& usecase,
+                                                     const std::string& iface,
+                                                     const std::vector<std::string>& appStrUids,
+                                                     IptOp op) {
+    int ret;
+    std::string chain;
+
+    // Sanity check inputs against our local restriction accounting
+    ret = appsOnInterfaceAccounting(usecase, appStrUids, op, false /* update */);
+    if (ret != 0) {
+        return ret;
+    }
+
+    if (mBpfSupported) {
+        // map use case to blacklist interface slot
+        int blacklistSlot = -1;
+        for (unsigned int i = 0; i < APP_RESTRICT_USE_CASES.size(); i++) {
+            if (usecase == APP_RESTRICT_USE_CASES[i]) {
+                blacklistSlot = (int) i;
+                break;
+            }
+        }
+        if (blacklistSlot < 0) {
+            ALOGE("unknown app restrict usecase: %s", usecase.c_str());
+            return -1;
+        }
+        Status status;
+        if (op == IptOpInsert) {
+            uint32_t ifaceIdx = android::net::RouteController::getIfIndex(iface.c_str());
+            if (!ifaceIdx) {
+                // Interface is unknown or down.
+                return -ENETDOWN;
+            }
+            status = gCtls->trafficCtrl.addUidInterfaceBlacklist(blacklistSlot, ifaceIdx,
+                                                                 appStrUids);
+        } else {
+            status = gCtls->trafficCtrl.removeUidInterfaceBlacklist(blacklistSlot, appStrUids);
+        }
+        if (!isOk(status)) {
+            ALOGE("unable to update Bandwidth interface rule: %s", toString(status).c_str());
+            return status.code();
+        }
+    } else { // !mBpfSupported
+        // Use iptables if BPF is not supported
+        chain = StringPrintf("INPUT -i %s", iface.c_str());
+        ret = manipulateSpecialApps(appStrUids, chain, IptJumpReject, op);
+        if (ret != 0) {
+            return ret;
+        }
+        chain = StringPrintf("OUTPUT -o %s", iface.c_str());
+        ret = manipulateSpecialApps(appStrUids, chain, IptJumpReject, op);
+        if (ret != 0) {
+            return ret;
+        }
+    }
+
+    return appsOnInterfaceAccounting(usecase, appStrUids, op, true /* update */);
+}
+
 int BandwidthController::manipulateSpecialApps(const std::vector<std::string>& appStrUids,
                                                const std::string& chain, IptJumpOp jumpHandling,
                                                IptOp op) {
diff --git a/server/BandwidthController.h b/server/BandwidthController.h
index b8691dcc..850326a8 100644
--- a/server/BandwidthController.h
+++ b/server/BandwidthController.h
@@ -57,6 +57,11 @@ public:
     int addNiceApps(const std::vector<std::string>& appStrUid);
     int removeNiceApps(const std::vector<std::string>& appStrUid);
 
+    int addRestrictAppsOnInterface(const std::string& usecase, const std::string& iface,
+                                   const std::vector<std::string>& appStrUid);
+    int removeRestrictAppsOnInterface(const std::string& usecase, const std::string& iface,
+                                      const std::vector<std::string>& appStrUid);
+
     int setGlobalAlert(int64_t bytes);
     int removeGlobalAlert();
     int setGlobalAlertInForwardChain();
@@ -96,6 +101,13 @@ public:
 
     std::string makeDataSaverCommand(IptablesTarget target, bool enable);
 
+    int manipulateRestrictAppsInOut(const std::string& usecase, const std::string& iface,
+                                    const std::vector<std::string>& appStrUids, IptOp appOp);
+
+    int appsOnInterfaceAccounting(const std::string& usecase,
+                                  const std::vector<std::string>& appStrUids,
+                                  IptOp op, bool update);
+
     int manipulateSpecialApps(const std::vector<std::string>& appStrUids, const std::string& chain,
                               IptJumpOp jumpHandling, IptOp appOp);
 
@@ -140,6 +152,8 @@ public:
 
     std::map<std::string, QuotaInfo> mQuotaIfaces;
     std::set<std::string> mSharedQuotaIfaces;
+
+    std::map<std::string /* interface name*/, std::vector<int /*appUid*/>> mRestrictAppsOnInterface;
 };
 
 #endif
diff --git a/server/NetdNativeService.cpp b/server/NetdNativeService.cpp
index 3bf879bf..cb3ea391 100644
--- a/server/NetdNativeService.cpp
+++ b/server/NetdNativeService.cpp
@@ -342,6 +342,22 @@ binder::Status NetdNativeService::bandwidthRemoveNiceApp(int32_t uid) {
     return statusFromErrcode(res);
 }
 
+binder::Status NetdNativeService::bandwidthAddRestrictAppOnInterface(const std::string& usecase,
+        const std::string& ifName, int32_t uid) {
+    NETD_LOCKING_RPC(gCtls->bandwidthCtrl.lock, PERM_NETWORK_STACK, PERM_MAINLINE_NETWORK_STACK);
+    std::vector<std::string> appStrUids = {std::to_string(abs(uid))};
+    int res = gCtls->bandwidthCtrl.addRestrictAppsOnInterface(usecase, ifName, appStrUids);
+    return statusFromErrcode(res);
+}
+
+binder::Status NetdNativeService::bandwidthRemoveRestrictAppOnInterface(const std::string& usecase,
+        const std::string& ifName, int32_t uid) {
+    NETD_LOCKING_RPC(gCtls->bandwidthCtrl.lock, PERM_NETWORK_STACK, PERM_MAINLINE_NETWORK_STACK);
+    std::vector<std::string> appStrUids = {std::to_string(abs(uid))};
+    int res = gCtls->bandwidthCtrl.removeRestrictAppsOnInterface(usecase, ifName, appStrUids);
+    return statusFromErrcode(res);
+}
+
 binder::Status NetdNativeService::networkCreatePhysical(int32_t netId, int32_t permission) {
     ENFORCE_NETWORK_STACK_PERMISSIONS();
     int ret = gCtls->netCtrl.createPhysicalNetwork(netId, convertPermission(permission));
diff --git a/server/NetdNativeService.h b/server/NetdNativeService.h
index 7b7f9b33..f40a8afc 100644
--- a/server/NetdNativeService.h
+++ b/server/NetdNativeService.h
@@ -61,6 +61,12 @@ class NetdNativeService : public BinderService<NetdNativeService>, public BnNetd
     binder::Status bandwidthRemoveNaughtyApp(int32_t uid) override;
     binder::Status bandwidthAddNiceApp(int32_t uid) override;
     binder::Status bandwidthRemoveNiceApp(int32_t uid) override;
+    binder::Status bandwidthAddRestrictAppOnInterface(const std::string& usecase,
+                                                      const std::string& ifName,
+                                                      int32_t uid);
+    binder::Status bandwidthRemoveRestrictAppOnInterface(const std::string& usecase,
+                                                         const std::string& ifName,
+                                                         int32_t uid);
 
     // Network and routing commands.
     binder::Status networkCreatePhysical(int32_t netId, int32_t permission) override;
diff --git a/server/TrafficController.cpp b/server/TrafficController.cpp
index 3839962f..7ef6a3ee 100644
--- a/server/TrafficController.cpp
+++ b/server/TrafficController.cpp
@@ -101,6 +101,7 @@ const std::string uidMatchTypeToString(uint8_t match) {
     FLAG_MSG_TRANS(matchType, STANDBY_MATCH, match);
     FLAG_MSG_TRANS(matchType, POWERSAVE_MATCH, match);
     FLAG_MSG_TRANS(matchType, IIF_MATCH, match);
+    FLAG_MSG_TRANS(matchType, IF_BLACKLIST, match);
     if (match) {
         return StringPrintf("Unknown match: %u", match);
     }
@@ -544,13 +545,30 @@ UidOwnerMatchType TrafficController::jumpOpToMatch(BandwidthController::IptJumpO
 }
 
 Status TrafficController::removeRule(BpfMap<uint32_t, UidOwnerValue>& map, uint32_t uid,
-                                     UidOwnerMatchType match) {
+                                     UidOwnerMatchType match, uint32_t ifBlacklistSlot) {
+    if (match & IF_BLACKLIST && ifBlacklistSlot >= UID_MAX_IF_BLACKLIST) {
+        return statusFromErrno(EINVAL, StringPrintf("Interface rule iface slot is out of range: %d",
+                                                    ifBlacklistSlot));
+    }
     auto oldMatch = map.readValue(uid);
     if (oldMatch.ok()) {
         UidOwnerValue newMatch = {
                 .iif = (match == IIF_MATCH) ? 0 : oldMatch.value().iif,
                 .rule = static_cast<uint8_t>(oldMatch.value().rule & ~match),
         };
+        // Copy previous set of blacklisted interfaces
+        memcpy(newMatch.if_blacklist, oldMatch.value().if_blacklist, sizeof(newMatch.if_blacklist));
+        // If this is a remove blacklisted interface call, clear the slot requested.
+        if (match & IF_BLACKLIST) {
+            newMatch.if_blacklist[ifBlacklistSlot] = 0;
+            // Check if any IF_BLACKLIST interfaces remain
+            for (int i = 0; i < UID_MAX_IF_BLACKLIST; i++) {
+                if (newMatch.if_blacklist[i] > 0) {
+                    newMatch.rule |= IF_BLACKLIST;
+                    break;
+                }
+            }
+        }
         if (newMatch.rule == 0) {
             RETURN_IF_NOT_OK(map.deleteValue(uid));
         } else {
@@ -563,27 +581,46 @@ Status TrafficController::removeRule(BpfMap<uint32_t, UidOwnerValue>& map, uint3
 }
 
 Status TrafficController::addRule(BpfMap<uint32_t, UidOwnerValue>& map, uint32_t uid,
-                                  UidOwnerMatchType match, uint32_t iif) {
-    // iif should be non-zero if and only if match == MATCH_IIF
-    if (match == IIF_MATCH && iif == 0) {
+                                  UidOwnerMatchType match, uint32_t iif, uint32_t ifBlacklistSlot) {
+    if ((match & IIF_MATCH) && (match & IF_BLACKLIST)) {
+        return statusFromErrno(EINVAL, "Cannot match on IIF_MATCH and IF_BLACKLIST in the "
+                                       "same addRule call");
+    }
+    if ((match & IF_BLACKLIST) && ifBlacklistSlot >= UID_MAX_IF_BLACKLIST) {
+        return statusFromErrno(EINVAL, StringPrintf("Interface rule iface slot is out of range: %d",
+                                                    ifBlacklistSlot));
+    }
+
+    // iif should be non-zero if and only if match & (IIF_MATCH | IF_BLACKLIST)
+    if ((match & (IIF_MATCH | IF_BLACKLIST)) && iif == 0) {
         return statusFromErrno(EINVAL, "Interface match must have nonzero interface index");
-    } else if (match != IIF_MATCH && iif != 0) {
+    } else if (!(match & (IIF_MATCH | IF_BLACKLIST)) && iif != 0) {
         return statusFromErrno(EINVAL, "Non-interface match must have zero interface index");
     }
     auto oldMatch = map.readValue(uid);
+    UidOwnerValue newMatch;
     if (oldMatch.ok()) {
-        UidOwnerValue newMatch = {
+        newMatch = {
                 .iif = iif ? iif : oldMatch.value().iif,
                 .rule = static_cast<uint8_t>(oldMatch.value().rule | match),
         };
-        RETURN_IF_NOT_OK(map.writeValue(uid, newMatch, BPF_ANY));
+        // Copy previous set of blacklisted interfaces
+        memcpy(newMatch.if_blacklist, oldMatch.value().if_blacklist, sizeof(newMatch.if_blacklist));
     } else {
-        UidOwnerValue newMatch = {
+        newMatch = {
                 .iif = iif,
                 .rule = static_cast<uint8_t>(match),
         };
-        RETURN_IF_NOT_OK(map.writeValue(uid, newMatch, BPF_ANY));
+        for (int i = 0; i < UID_MAX_IF_BLACKLIST; i++) {
+                    newMatch.if_blacklist[i] = 0;
+        }
     }
+    if (match & IIF_MATCH) {
+        newMatch.iif = iif;
+    } else if (match & IF_BLACKLIST) {
+        newMatch.if_blacklist[ifBlacklistSlot] = iif;
+    }
+    RETURN_IF_NOT_OK(map.writeValue(uid, newMatch, BPF_ANY));
     return netdutils::status::ok;
 }
 
@@ -705,6 +742,47 @@ Status TrafficController::removeUidInterfaceRules(const std::vector<int32_t>& ui
     return netdutils::status::ok;
 }
 
+Status TrafficController::addUidInterfaceBlacklist(const int ifBlacklistSlot, const int iface,
+                                                   const std::vector<std::string>& appStrUids) {
+    if (!mBpfEnabled) {
+        ALOGW("UID ingress interface filtering not possible without BPF owner match");
+        return statusFromErrno(EOPNOTSUPP, "eBPF not supported");
+    }
+    if (!iface) {
+        return statusFromErrno(EINVAL, "Interface rule must specify interface");
+    }
+    std::lock_guard guard(mMutex);
+
+    for (const auto& appStrUid : appStrUids) {
+        uint32_t uid = (uint32_t) std::stoi(appStrUid, nullptr, 0);
+        netdutils::Status result = addRule(mUidOwnerMap, uid, IF_BLACKLIST, iface, ifBlacklistSlot);
+        if (!isOk(result)) {
+            ALOGW("addRule failed(%d): uid=%d iface=%d ifBlacklistSlot=%d "
+                  "(addUidInterfaceBlacklist)", result.code(), uid, iface, ifBlacklistSlot);
+        }
+    }
+    return netdutils::status::ok;
+}
+
+Status TrafficController::removeUidInterfaceBlacklist(const int ifBlacklistSlot,
+                                                      const std::vector<std::string>& appStrUids) {
+    if (!mBpfEnabled) {
+        ALOGW("UID ingress interface filtering not possible without BPF owner match");
+        return statusFromErrno(EOPNOTSUPP, "eBPF not supported");
+    }
+    std::lock_guard guard(mMutex);
+
+    for (const auto& appStrUid : appStrUids) {
+        uint32_t uid = (uint32_t) std::stoi(appStrUid, nullptr, 0);
+        netdutils::Status result = removeRule(mUidOwnerMap, uid, IF_BLACKLIST, ifBlacklistSlot);
+        if (!isOk(result)) {
+            ALOGW("removeRule failed(%d): uid=%d ifBlacklistSlot=%d (removeUidInterfaceBlacklist)",
+                  result.code(), uid, ifBlacklistSlot);
+        }
+    }
+    return netdutils::status::ok;
+}
+
 int TrafficController::replaceUidOwnerMap(const std::string& name, bool isWhitelist __unused,
                                           const std::vector<int32_t>& uids) {
     // FirewallRule rule = isWhitelist ? ALLOW : DENY;
diff --git a/server/TrafficController.h b/server/TrafficController.h
index a2539a90..4c50525c 100644
--- a/server/TrafficController.h
+++ b/server/TrafficController.h
@@ -112,6 +112,13 @@ class TrafficController {
             EXCLUDES(mMutex);
     netdutils::Status removeUidInterfaceRules(const std::vector<int32_t>& uids) EXCLUDES(mMutex);
 
+    netdutils::Status addUidInterfaceBlacklist(const int ifBlacklistSlot, const int iface,
+                                               const std::vector<std::string>& appStrUids)
+                                               EXCLUDES(mMutex);
+    netdutils::Status removeUidInterfaceBlacklist(const int ifBlacklistSlot,
+                                                  const std::vector<std::string>& appStrUids)
+                                                  EXCLUDES(mMutex);
+
     netdutils::Status updateUidOwnerMap(const std::vector<std::string>& appStrUids,
                                         BandwidthController::IptJumpOp jumpHandling,
                                         BandwidthController::IptOp op) EXCLUDES(mMutex);
@@ -204,10 +211,12 @@ class TrafficController {
     std::unique_ptr<NetlinkListenerInterface> mSkDestroyListener;
 
     netdutils::Status removeRule(BpfMap<uint32_t, UidOwnerValue>& map, uint32_t uid,
-                                 UidOwnerMatchType match) REQUIRES(mMutex);
+                                 UidOwnerMatchType match, uint32_t ifBlacklistSlot = 0)
+                                 REQUIRES(mMutex);
 
     netdutils::Status addRule(BpfMap<uint32_t, UidOwnerValue>& map, uint32_t uid,
-                              UidOwnerMatchType match, uint32_t iif = 0) REQUIRES(mMutex);
+                              UidOwnerMatchType match, uint32_t iif = 0,
+                              uint32_t ifBlacklistSlot = 0) REQUIRES(mMutex);
 
     bool mBpfEnabled;
 
diff --git a/server/aidl_api/netd_aidl_interface/5/.hash b/server/aidl_api/netd_aidl_interface/5/.hash
new file mode 100644
index 00000000..dd162ef8
--- /dev/null
+++ b/server/aidl_api/netd_aidl_interface/5/.hash
@@ -0,0 +1 @@
+00d97856cb8c0bbd218bcd6592e5367e7f0dae16
diff --git a/server/aidl_api/netd_aidl_interface/5/android/net/INetd.aidl b/server/aidl_api/netd_aidl_interface/5/android/net/INetd.aidl
new file mode 100644
index 00000000..59ee5ee1
--- /dev/null
+++ b/server/aidl_api/netd_aidl_interface/5/android/net/INetd.aidl
@@ -0,0 +1,166 @@
+///////////////////////////////////////////////////////////////////////////////
+// THIS FILE IS IMMUTABLE. DO NOT EDIT IN ANY CASE.                          //
+///////////////////////////////////////////////////////////////////////////////
+
+// This file is a snapshot of an AIDL interface (or parcelable). Do not try to
+// edit this file. It looks like you are doing that because you have modified
+// an AIDL interface in a backward-incompatible way, e.g., deleting a function
+// from an interface or a field from a parcelable and it broke the build. That
+// breakage is intended.
+//
+// You must not make a backward incompatible changes to the AIDL files built
+// with the aidl_interface module type with versions property set. The module
+// type is used to build AIDL files in a way that they can be used across
+// independently updatable components of the system. If a device is shipped
+// with such a backward incompatible change, it has a high risk of breaking
+// later when a module using the interface is updated, e.g., Mainline modules.
+
+package android.net;
+/* @hide */
+interface INetd {
+  boolean isAlive();
+  boolean firewallReplaceUidChain(in @utf8InCpp String chainName, boolean isWhitelist, in int[] uids);
+  boolean bandwidthEnableDataSaver(boolean enable);
+  void networkCreatePhysical(int netId, int permission);
+  void networkCreateVpn(int netId, boolean secure);
+  void networkDestroy(int netId);
+  void networkAddInterface(int netId, in @utf8InCpp String iface);
+  void networkRemoveInterface(int netId, in @utf8InCpp String iface);
+  void networkAddUidRanges(int netId, in android.net.UidRangeParcel[] uidRanges);
+  void networkRemoveUidRanges(int netId, in android.net.UidRangeParcel[] uidRanges);
+  void networkRejectNonSecureVpn(boolean add, in android.net.UidRangeParcel[] uidRanges);
+  void socketDestroy(in android.net.UidRangeParcel[] uidRanges, in int[] exemptUids);
+  boolean tetherApplyDnsInterfaces();
+  android.net.TetherStatsParcel[] tetherGetStats();
+  void interfaceAddAddress(in @utf8InCpp String ifName, in @utf8InCpp String addrString, int prefixLength);
+  void interfaceDelAddress(in @utf8InCpp String ifName, in @utf8InCpp String addrString, int prefixLength);
+  @utf8InCpp String getProcSysNet(int ipversion, int which, in @utf8InCpp String ifname, in @utf8InCpp String parameter);
+  void setProcSysNet(int ipversion, int which, in @utf8InCpp String ifname, in @utf8InCpp String parameter, in @utf8InCpp String value);
+  void ipSecSetEncapSocketOwner(in ParcelFileDescriptor socket, int newUid);
+  int ipSecAllocateSpi(int transformId, in @utf8InCpp String sourceAddress, in @utf8InCpp String destinationAddress, int spi);
+  void ipSecAddSecurityAssociation(int transformId, int mode, in @utf8InCpp String sourceAddress, in @utf8InCpp String destinationAddress, int underlyingNetId, int spi, int markValue, int markMask, in @utf8InCpp String authAlgo, in byte[] authKey, in int authTruncBits, in @utf8InCpp String cryptAlgo, in byte[] cryptKey, in int cryptTruncBits, in @utf8InCpp String aeadAlgo, in byte[] aeadKey, in int aeadIcvBits, int encapType, int encapLocalPort, int encapRemotePort, int interfaceId);
+  void ipSecDeleteSecurityAssociation(int transformId, in @utf8InCpp String sourceAddress, in @utf8InCpp String destinationAddress, int spi, int markValue, int markMask, int interfaceId);
+  void ipSecApplyTransportModeTransform(in ParcelFileDescriptor socket, int transformId, int direction, in @utf8InCpp String sourceAddress, in @utf8InCpp String destinationAddress, int spi);
+  void ipSecRemoveTransportModeTransform(in ParcelFileDescriptor socket);
+  void ipSecAddSecurityPolicy(int transformId, int selAddrFamily, int direction, in @utf8InCpp String tmplSrcAddress, in @utf8InCpp String tmplDstAddress, int spi, int markValue, int markMask, int interfaceId);
+  void ipSecUpdateSecurityPolicy(int transformId, int selAddrFamily, int direction, in @utf8InCpp String tmplSrcAddress, in @utf8InCpp String tmplDstAddress, int spi, int markValue, int markMask, int interfaceId);
+  void ipSecDeleteSecurityPolicy(int transformId, int selAddrFamily, int direction, int markValue, int markMask, int interfaceId);
+  void ipSecAddTunnelInterface(in @utf8InCpp String deviceName, in @utf8InCpp String localAddress, in @utf8InCpp String remoteAddress, int iKey, int oKey, int interfaceId);
+  void ipSecUpdateTunnelInterface(in @utf8InCpp String deviceName, in @utf8InCpp String localAddress, in @utf8InCpp String remoteAddress, int iKey, int oKey, int interfaceId);
+  void ipSecRemoveTunnelInterface(in @utf8InCpp String deviceName);
+  void wakeupAddInterface(in @utf8InCpp String ifName, in @utf8InCpp String prefix, int mark, int mask);
+  void wakeupDelInterface(in @utf8InCpp String ifName, in @utf8InCpp String prefix, int mark, int mask);
+  void setIPv6AddrGenMode(in @utf8InCpp String ifName, int mode);
+  void idletimerAddInterface(in @utf8InCpp String ifName, int timeout, in @utf8InCpp String classLabel);
+  void idletimerRemoveInterface(in @utf8InCpp String ifName, int timeout, in @utf8InCpp String classLabel);
+  void strictUidCleartextPenalty(int uid, int policyPenalty);
+  @utf8InCpp String clatdStart(in @utf8InCpp String ifName, in @utf8InCpp String nat64Prefix);
+  void clatdStop(in @utf8InCpp String ifName);
+  boolean ipfwdEnabled();
+  @utf8InCpp String[] ipfwdGetRequesterList();
+  void ipfwdEnableForwarding(in @utf8InCpp String requester);
+  void ipfwdDisableForwarding(in @utf8InCpp String requester);
+  void ipfwdAddInterfaceForward(in @utf8InCpp String fromIface, in @utf8InCpp String toIface);
+  void ipfwdRemoveInterfaceForward(in @utf8InCpp String fromIface, in @utf8InCpp String toIface);
+  void bandwidthSetInterfaceQuota(in @utf8InCpp String ifName, long bytes);
+  void bandwidthRemoveInterfaceQuota(in @utf8InCpp String ifName);
+  void bandwidthSetInterfaceAlert(in @utf8InCpp String ifName, long bytes);
+  void bandwidthRemoveInterfaceAlert(in @utf8InCpp String ifName);
+  void bandwidthSetGlobalAlert(long bytes);
+  void bandwidthAddNaughtyApp(int uid);
+  void bandwidthRemoveNaughtyApp(int uid);
+  void bandwidthAddNiceApp(int uid);
+  void bandwidthRemoveNiceApp(int uid);
+  void tetherStart(in @utf8InCpp String[] dhcpRanges);
+  void tetherStop();
+  boolean tetherIsEnabled();
+  void tetherInterfaceAdd(in @utf8InCpp String ifName);
+  void tetherInterfaceRemove(in @utf8InCpp String ifName);
+  @utf8InCpp String[] tetherInterfaceList();
+  void tetherDnsSet(int netId, in @utf8InCpp String[] dnsAddrs);
+  @utf8InCpp String[] tetherDnsList();
+  void networkAddRoute(int netId, in @utf8InCpp String ifName, in @utf8InCpp String destination, in @utf8InCpp String nextHop);
+  void networkRemoveRoute(int netId, in @utf8InCpp String ifName, in @utf8InCpp String destination, in @utf8InCpp String nextHop);
+  void networkAddLegacyRoute(int netId, in @utf8InCpp String ifName, in @utf8InCpp String destination, in @utf8InCpp String nextHop, int uid);
+  void networkRemoveLegacyRoute(int netId, in @utf8InCpp String ifName, in @utf8InCpp String destination, in @utf8InCpp String nextHop, int uid);
+  int networkGetDefault();
+  void networkSetDefault(int netId);
+  void networkClearDefault();
+  void networkSetPermissionForNetwork(int netId, int permission);
+  void networkSetPermissionForUser(int permission, in int[] uids);
+  void networkClearPermissionForUser(in int[] uids);
+  void trafficSetNetPermForUids(int permission, in int[] uids);
+  void networkSetProtectAllow(int uid);
+  void networkSetProtectDeny(int uid);
+  boolean networkCanProtect(int uid);
+  void firewallSetFirewallType(int firewalltype);
+  void firewallSetInterfaceRule(in @utf8InCpp String ifName, int firewallRule);
+  void firewallSetUidRule(int childChain, int uid, int firewallRule);
+  void firewallEnableChildChain(int childChain, boolean enable);
+  @utf8InCpp String[] interfaceGetList();
+  android.net.InterfaceConfigurationParcel interfaceGetCfg(in @utf8InCpp String ifName);
+  void interfaceSetCfg(in android.net.InterfaceConfigurationParcel cfg);
+  void interfaceSetIPv6PrivacyExtensions(in @utf8InCpp String ifName, boolean enable);
+  void interfaceClearAddrs(in @utf8InCpp String ifName);
+  void interfaceSetEnableIPv6(in @utf8InCpp String ifName, boolean enable);
+  void interfaceSetMtu(in @utf8InCpp String ifName, int mtu);
+  void tetherAddForward(in @utf8InCpp String intIface, in @utf8InCpp String extIface);
+  void tetherRemoveForward(in @utf8InCpp String intIface, in @utf8InCpp String extIface);
+  void setTcpRWmemorySize(in @utf8InCpp String rmemValues, in @utf8InCpp String wmemValues);
+  void registerUnsolicitedEventListener(android.net.INetdUnsolicitedEventListener listener);
+  void firewallAddUidInterfaceRules(in @utf8InCpp String ifName, in int[] uids);
+  void firewallRemoveUidInterfaceRules(in int[] uids);
+  void trafficSwapActiveStatsMap();
+  IBinder getOemNetd();
+  void tetherStartWithConfiguration(in android.net.TetherConfigParcel config);
+  android.net.MarkMaskParcel getFwmarkForNetwork(int netId);
+  void networkAddRouteParcel(int netId, in android.net.RouteInfoParcel routeInfo);
+  void networkUpdateRouteParcel(int netId, in android.net.RouteInfoParcel routeInfo);
+  void networkRemoveRouteParcel(int netId, in android.net.RouteInfoParcel routeInfo);
+  void tetherOffloadRuleAdd(in android.net.TetherOffloadRuleParcel rule);
+  void tetherOffloadRuleRemove(in android.net.TetherOffloadRuleParcel rule);
+  android.net.TetherStatsParcel[] tetherOffloadGetStats();
+  void tetherOffloadSetInterfaceQuota(int ifIndex, long quotaBytes);
+  android.net.TetherStatsParcel tetherOffloadGetAndClearStats(int ifIndex);
+  void bandwidthAddRestrictAppOnInterface(in @utf8InCpp String usecase, in @utf8InCpp String ifName, int uid);
+  void bandwidthRemoveRestrictAppOnInterface(in @utf8InCpp String usecase, in @utf8InCpp String ifName, int uid);
+  const int IPV4 = 4;
+  const int IPV6 = 6;
+  const int CONF = 1;
+  const int NEIGH = 2;
+  const String IPSEC_INTERFACE_PREFIX = "ipsec";
+  const int IPV6_ADDR_GEN_MODE_EUI64 = 0;
+  const int IPV6_ADDR_GEN_MODE_NONE = 1;
+  const int IPV6_ADDR_GEN_MODE_STABLE_PRIVACY = 2;
+  const int IPV6_ADDR_GEN_MODE_RANDOM = 3;
+  const int IPV6_ADDR_GEN_MODE_DEFAULT = 0;
+  const int PENALTY_POLICY_ACCEPT = 1;
+  const int PENALTY_POLICY_LOG = 2;
+  const int PENALTY_POLICY_REJECT = 3;
+  const int LOCAL_NET_ID = 99;
+  const String NEXTHOP_NONE = "";
+  const String NEXTHOP_UNREACHABLE = "unreachable";
+  const String NEXTHOP_THROW = "throw";
+  const int PERMISSION_NONE = 0;
+  const int PERMISSION_NETWORK = 1;
+  const int PERMISSION_SYSTEM = 2;
+  const int NO_PERMISSIONS = 0;
+  const int PERMISSION_INTERNET = 4;
+  const int PERMISSION_UPDATE_DEVICE_STATS = 8;
+  const int PERMISSION_UNINSTALLED = -1;
+  const int FIREWALL_WHITELIST = 0;
+  const int FIREWALL_BLACKLIST = 1;
+  const int FIREWALL_RULE_ALLOW = 1;
+  const int FIREWALL_RULE_DENY = 2;
+  const int FIREWALL_CHAIN_NONE = 0;
+  const int FIREWALL_CHAIN_DOZABLE = 1;
+  const int FIREWALL_CHAIN_STANDBY = 2;
+  const int FIREWALL_CHAIN_POWERSAVE = 3;
+  const String IF_STATE_UP = "up";
+  const String IF_STATE_DOWN = "down";
+  const String IF_FLAG_BROADCAST = "broadcast";
+  const String IF_FLAG_LOOPBACK = "loopback";
+  const String IF_FLAG_POINTOPOINT = "point-to-point";
+  const String IF_FLAG_RUNNING = "running";
+  const String IF_FLAG_MULTICAST = "multicast";
+}
diff --git a/server/aidl_api/netd_aidl_interface/5/android/net/INetdUnsolicitedEventListener.aidl b/server/aidl_api/netd_aidl_interface/5/android/net/INetdUnsolicitedEventListener.aidl
new file mode 100644
index 00000000..44593632
--- /dev/null
+++ b/server/aidl_api/netd_aidl_interface/5/android/net/INetdUnsolicitedEventListener.aidl
@@ -0,0 +1,32 @@
+///////////////////////////////////////////////////////////////////////////////
+// THIS FILE IS IMMUTABLE. DO NOT EDIT IN ANY CASE.                          //
+///////////////////////////////////////////////////////////////////////////////
+
+// This file is a snapshot of an AIDL interface (or parcelable). Do not try to
+// edit this file. It looks like you are doing that because you have modified
+// an AIDL interface in a backward-incompatible way, e.g., deleting a function
+// from an interface or a field from a parcelable and it broke the build. That
+// breakage is intended.
+//
+// You must not make a backward incompatible changes to the AIDL files built
+// with the aidl_interface module type with versions property set. The module
+// type is used to build AIDL files in a way that they can be used across
+// independently updatable components of the system. If a device is shipped
+// with such a backward incompatible change, it has a high risk of breaking
+// later when a module using the interface is updated, e.g., Mainline modules.
+
+package android.net;
+/* @hide */
+interface INetdUnsolicitedEventListener {
+  oneway void onInterfaceClassActivityChanged(boolean isActive, int timerLabel, long timestampNs, int uid);
+  oneway void onQuotaLimitReached(@utf8InCpp String alertName, @utf8InCpp String ifName);
+  oneway void onInterfaceDnsServerInfo(@utf8InCpp String ifName, long lifetimeS, in @utf8InCpp String[] servers);
+  oneway void onInterfaceAddressUpdated(@utf8InCpp String addr, @utf8InCpp String ifName, int flags, int scope);
+  oneway void onInterfaceAddressRemoved(@utf8InCpp String addr, @utf8InCpp String ifName, int flags, int scope);
+  oneway void onInterfaceAdded(@utf8InCpp String ifName);
+  oneway void onInterfaceRemoved(@utf8InCpp String ifName);
+  oneway void onInterfaceChanged(@utf8InCpp String ifName, boolean up);
+  oneway void onInterfaceLinkStateChanged(@utf8InCpp String ifName, boolean up);
+  oneway void onRouteChanged(boolean updated, @utf8InCpp String route, @utf8InCpp String gateway, @utf8InCpp String ifName);
+  oneway void onStrictCleartextDetected(int uid, @utf8InCpp String hex);
+}
diff --git a/server/aidl_api/netd_aidl_interface/5/android/net/InterfaceConfigurationParcel.aidl b/server/aidl_api/netd_aidl_interface/5/android/net/InterfaceConfigurationParcel.aidl
new file mode 100644
index 00000000..01e0f955
--- /dev/null
+++ b/server/aidl_api/netd_aidl_interface/5/android/net/InterfaceConfigurationParcel.aidl
@@ -0,0 +1,26 @@
+///////////////////////////////////////////////////////////////////////////////
+// THIS FILE IS IMMUTABLE. DO NOT EDIT IN ANY CASE.                          //
+///////////////////////////////////////////////////////////////////////////////
+
+// This file is a snapshot of an AIDL interface (or parcelable). Do not try to
+// edit this file. It looks like you are doing that because you have modified
+// an AIDL interface in a backward-incompatible way, e.g., deleting a function
+// from an interface or a field from a parcelable and it broke the build. That
+// breakage is intended.
+//
+// You must not make a backward incompatible changes to the AIDL files built
+// with the aidl_interface module type with versions property set. The module
+// type is used to build AIDL files in a way that they can be used across
+// independently updatable components of the system. If a device is shipped
+// with such a backward incompatible change, it has a high risk of breaking
+// later when a module using the interface is updated, e.g., Mainline modules.
+
+package android.net;
+/* @hide */
+parcelable InterfaceConfigurationParcel {
+  @utf8InCpp String ifName;
+  @utf8InCpp String hwAddr;
+  @utf8InCpp String ipv4Addr;
+  int prefixLength;
+  @utf8InCpp String[] flags;
+}
diff --git a/server/aidl_api/netd_aidl_interface/5/android/net/MarkMaskParcel.aidl b/server/aidl_api/netd_aidl_interface/5/android/net/MarkMaskParcel.aidl
new file mode 100644
index 00000000..62be8384
--- /dev/null
+++ b/server/aidl_api/netd_aidl_interface/5/android/net/MarkMaskParcel.aidl
@@ -0,0 +1,23 @@
+///////////////////////////////////////////////////////////////////////////////
+// THIS FILE IS IMMUTABLE. DO NOT EDIT IN ANY CASE.                          //
+///////////////////////////////////////////////////////////////////////////////
+
+// This file is a snapshot of an AIDL interface (or parcelable). Do not try to
+// edit this file. It looks like you are doing that because you have modified
+// an AIDL interface in a backward-incompatible way, e.g., deleting a function
+// from an interface or a field from a parcelable and it broke the build. That
+// breakage is intended.
+//
+// You must not make a backward incompatible changes to the AIDL files built
+// with the aidl_interface module type with versions property set. The module
+// type is used to build AIDL files in a way that they can be used across
+// independently updatable components of the system. If a device is shipped
+// with such a backward incompatible change, it has a high risk of breaking
+// later when a module using the interface is updated, e.g., Mainline modules.
+
+package android.net;
+/* @hide */
+parcelable MarkMaskParcel {
+  int mark;
+  int mask;
+}
diff --git a/server/aidl_api/netd_aidl_interface/5/android/net/RouteInfoParcel.aidl b/server/aidl_api/netd_aidl_interface/5/android/net/RouteInfoParcel.aidl
new file mode 100644
index 00000000..5e0ee62a
--- /dev/null
+++ b/server/aidl_api/netd_aidl_interface/5/android/net/RouteInfoParcel.aidl
@@ -0,0 +1,24 @@
+///////////////////////////////////////////////////////////////////////////////
+// THIS FILE IS IMMUTABLE. DO NOT EDIT IN ANY CASE.                          //
+///////////////////////////////////////////////////////////////////////////////
+
+// This file is a snapshot of an AIDL interface (or parcelable). Do not try to
+// edit this file. It looks like you are doing that because you have modified
+// an AIDL interface in a backward-incompatible way, e.g., deleting a function
+// from an interface or a field from a parcelable and it broke the build. That
+// breakage is intended.
+//
+// You must not make a backward incompatible changes to the AIDL files built
+// with the aidl_interface module type with versions property set. The module
+// type is used to build AIDL files in a way that they can be used across
+// independently updatable components of the system. If a device is shipped
+// with such a backward incompatible change, it has a high risk of breaking
+// later when a module using the interface is updated, e.g., Mainline modules.
+
+package android.net;
+parcelable RouteInfoParcel {
+  @utf8InCpp String destination;
+  @utf8InCpp String ifName;
+  @utf8InCpp String nextHop;
+  int mtu;
+}
diff --git a/server/aidl_api/netd_aidl_interface/5/android/net/TetherConfigParcel.aidl b/server/aidl_api/netd_aidl_interface/5/android/net/TetherConfigParcel.aidl
new file mode 100644
index 00000000..b1364545
--- /dev/null
+++ b/server/aidl_api/netd_aidl_interface/5/android/net/TetherConfigParcel.aidl
@@ -0,0 +1,23 @@
+///////////////////////////////////////////////////////////////////////////////
+// THIS FILE IS IMMUTABLE. DO NOT EDIT IN ANY CASE.                          //
+///////////////////////////////////////////////////////////////////////////////
+
+// This file is a snapshot of an AIDL interface (or parcelable). Do not try to
+// edit this file. It looks like you are doing that because you have modified
+// an AIDL interface in a backward-incompatible way, e.g., deleting a function
+// from an interface or a field from a parcelable and it broke the build. That
+// breakage is intended.
+//
+// You must not make a backward incompatible changes to the AIDL files built
+// with the aidl_interface module type with versions property set. The module
+// type is used to build AIDL files in a way that they can be used across
+// independently updatable components of the system. If a device is shipped
+// with such a backward incompatible change, it has a high risk of breaking
+// later when a module using the interface is updated, e.g., Mainline modules.
+
+package android.net;
+/* @hide */
+parcelable TetherConfigParcel {
+  boolean usingLegacyDnsProxy;
+  @utf8InCpp String[] dhcpRanges;
+}
diff --git a/server/aidl_api/netd_aidl_interface/5/android/net/TetherOffloadRuleParcel.aidl b/server/aidl_api/netd_aidl_interface/5/android/net/TetherOffloadRuleParcel.aidl
new file mode 100644
index 00000000..c9d84580
--- /dev/null
+++ b/server/aidl_api/netd_aidl_interface/5/android/net/TetherOffloadRuleParcel.aidl
@@ -0,0 +1,28 @@
+///////////////////////////////////////////////////////////////////////////////
+// THIS FILE IS IMMUTABLE. DO NOT EDIT IN ANY CASE.                          //
+///////////////////////////////////////////////////////////////////////////////
+
+// This file is a snapshot of an AIDL interface (or parcelable). Do not try to
+// edit this file. It looks like you are doing that because you have modified
+// an AIDL interface in a backward-incompatible way, e.g., deleting a function
+// from an interface or a field from a parcelable and it broke the build. That
+// breakage is intended.
+//
+// You must not make a backward incompatible changes to the AIDL files built
+// with the aidl_interface module type with versions property set. The module
+// type is used to build AIDL files in a way that they can be used across
+// independently updatable components of the system. If a device is shipped
+// with such a backward incompatible change, it has a high risk of breaking
+// later when a module using the interface is updated, e.g., Mainline modules.
+
+package android.net;
+/* @hide */
+parcelable TetherOffloadRuleParcel {
+  int inputInterfaceIndex;
+  int outputInterfaceIndex;
+  byte[] destination;
+  int prefixLength;
+  byte[] srcL2Address;
+  byte[] dstL2Address;
+  int pmtu = 1500;
+}
diff --git a/server/aidl_api/netd_aidl_interface/5/android/net/TetherStatsParcel.aidl b/server/aidl_api/netd_aidl_interface/5/android/net/TetherStatsParcel.aidl
new file mode 100644
index 00000000..0b0960ef
--- /dev/null
+++ b/server/aidl_api/netd_aidl_interface/5/android/net/TetherStatsParcel.aidl
@@ -0,0 +1,27 @@
+///////////////////////////////////////////////////////////////////////////////
+// THIS FILE IS IMMUTABLE. DO NOT EDIT IN ANY CASE.                          //
+///////////////////////////////////////////////////////////////////////////////
+
+// This file is a snapshot of an AIDL interface (or parcelable). Do not try to
+// edit this file. It looks like you are doing that because you have modified
+// an AIDL interface in a backward-incompatible way, e.g., deleting a function
+// from an interface or a field from a parcelable and it broke the build. That
+// breakage is intended.
+//
+// You must not make a backward incompatible changes to the AIDL files built
+// with the aidl_interface module type with versions property set. The module
+// type is used to build AIDL files in a way that they can be used across
+// independently updatable components of the system. If a device is shipped
+// with such a backward incompatible change, it has a high risk of breaking
+// later when a module using the interface is updated, e.g., Mainline modules.
+
+package android.net;
+/* @hide */
+parcelable TetherStatsParcel {
+  @utf8InCpp String iface;
+  long rxBytes;
+  long rxPackets;
+  long txBytes;
+  long txPackets;
+  int ifIndex = 0;
+}
diff --git a/server/aidl_api/netd_aidl_interface/5/android/net/UidRangeParcel.aidl b/server/aidl_api/netd_aidl_interface/5/android/net/UidRangeParcel.aidl
new file mode 100644
index 00000000..84ff4572
--- /dev/null
+++ b/server/aidl_api/netd_aidl_interface/5/android/net/UidRangeParcel.aidl
@@ -0,0 +1,23 @@
+///////////////////////////////////////////////////////////////////////////////
+// THIS FILE IS IMMUTABLE. DO NOT EDIT IN ANY CASE.                          //
+///////////////////////////////////////////////////////////////////////////////
+
+// This file is a snapshot of an AIDL interface (or parcelable). Do not try to
+// edit this file. It looks like you are doing that because you have modified
+// an AIDL interface in a backward-incompatible way, e.g., deleting a function
+// from an interface or a field from a parcelable and it broke the build. That
+// breakage is intended.
+//
+// You must not make a backward incompatible changes to the AIDL files built
+// with the aidl_interface module type with versions property set. The module
+// type is used to build AIDL files in a way that they can be used across
+// independently updatable components of the system. If a device is shipped
+// with such a backward incompatible change, it has a high risk of breaking
+// later when a module using the interface is updated, e.g., Mainline modules.
+
+package android.net;
+/* @hide */
+parcelable UidRangeParcel {
+  int start;
+  int stop;
+}
diff --git a/server/aidl_api/netd_aidl_interface/current/android/net/INetd.aidl b/server/aidl_api/netd_aidl_interface/current/android/net/INetd.aidl
index 47e2931d..59ee5ee1 100644
--- a/server/aidl_api/netd_aidl_interface/current/android/net/INetd.aidl
+++ b/server/aidl_api/netd_aidl_interface/current/android/net/INetd.aidl
@@ -122,6 +122,8 @@ interface INetd {
   android.net.TetherStatsParcel[] tetherOffloadGetStats();
   void tetherOffloadSetInterfaceQuota(int ifIndex, long quotaBytes);
   android.net.TetherStatsParcel tetherOffloadGetAndClearStats(int ifIndex);
+  void bandwidthAddRestrictAppOnInterface(in @utf8InCpp String usecase, in @utf8InCpp String ifName, int uid);
+  void bandwidthRemoveRestrictAppOnInterface(in @utf8InCpp String usecase, in @utf8InCpp String ifName, int uid);
   const int IPV4 = 4;
   const int IPV6 = 6;
   const int CONF = 1;
diff --git a/server/binder/android/net/INetd.aidl b/server/binder/android/net/INetd.aidl
index 3b221cf0..7cb9ca26 100644
--- a/server/binder/android/net/INetd.aidl
+++ b/server/binder/android/net/INetd.aidl
@@ -1309,4 +1309,27 @@ interface INetd {
      *                                  cause of the failure.
      */
      TetherStatsParcel tetherOffloadGetAndClearStats(int ifIndex);
+
+    /* Add a network traffic restriction to/from an interface for a specific app
+    *
+    * @param usecase caller usecase
+    * @param ifName interface name
+    * @param uid uid of target app
+    * @throws ServiceSpecificException in case of failure, with an error code indicating the
+    *         cause of the failure.
+    */
+    void bandwidthAddRestrictAppOnInterface(in @utf8InCpp String usecase,
+            in @utf8InCpp String ifName, int uid);
+
+   /**
+    * Remove a network traffic restriction to/from an interface for a specific app
+    *
+    * @param usecase caller usecase
+    * @param ifName interface name
+    * @param uid uid of target app
+    * @throws ServiceSpecificException in case of failure, with an error code indicating the
+    *         cause of the failure.
+    */
+    void bandwidthRemoveRestrictAppOnInterface(in @utf8InCpp String usecase,
+            in @utf8InCpp String ifName, int uid);
 }
-- 
2.17.1

