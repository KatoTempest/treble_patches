From 8a57ff4039b81cb38c4495cd5773a3a759c9f5ae Mon Sep 17 00:00:00 2001
From: Victor Bo <bvoid@yandex.ru>
Date: Sat, 19 Dec 2020 12:15:42 -0500
Subject: [PATCH 2/2] touch response optimizations

  from
  https://github.com/syberia-project/platform_frameworks_native/commit/8a806c809d4ebc3fe07ae1689558946b08edebfe
---
 include/input/InputTransport.h |  9 +++++++--
 libs/input/InputTransport.cpp  | 19 +++++++++++++++----
 2 files changed, 22 insertions(+), 6 deletions(-)

diff --git a/include/input/InputTransport.h b/include/input/InputTransport.h
index 7ca9031f7..f5324d1fe 100644
--- a/include/input/InputTransport.h
+++ b/include/input/InputTransport.h
@@ -367,7 +367,8 @@ public:
      * Other errors probably indicate that the channel is broken.
      */
     status_t consume(InputEventFactoryInterface* factory, bool consumeBatches, nsecs_t frameTime,
-                     uint32_t* outSeq, InputEvent** outEvent);
+                     uint32_t* outSeq, InputEvent** outEvent,
+                     int* motionEventType, int* touchMoveNumber, bool* flag);
 
     /* Sends a finished signal to the publisher to inform it that the message
      * with the specified sequence number has finished being process and whether
@@ -412,6 +413,8 @@ public:
     int32_t getPendingBatchSource() const;
 
 private:
+    int mTouchMoveCounter = 0;
+
     // True if touch resampling is enabled.
     const bool mResampleTouch;
 
@@ -529,7 +532,9 @@ private:
     Vector<SeqChain> mSeqChains;
 
     status_t consumeBatch(InputEventFactoryInterface* factory,
-            nsecs_t frameTime, uint32_t* outSeq, InputEvent** outEvent);
+            nsecs_t frameTime, uint32_t* outSeq, InputEvent** outEvent,
+            int* touchMoveNumber);
+
     status_t consumeSamples(InputEventFactoryInterface* factory,
             Batch& batch, size_t count, uint32_t* outSeq, InputEvent** outEvent);
 
diff --git a/libs/input/InputTransport.cpp b/libs/input/InputTransport.cpp
index 11af23e1a..90a56ba71 100644
--- a/libs/input/InputTransport.cpp
+++ b/libs/input/InputTransport.cpp
@@ -609,7 +609,8 @@ bool InputConsumer::isTouchResamplingEnabled() {
 }
 
 status_t InputConsumer::consume(InputEventFactoryInterface* factory, bool consumeBatches,
-                                nsecs_t frameTime, uint32_t* outSeq, InputEvent** outEvent) {
+                                nsecs_t frameTime, uint32_t* outSeq, InputEvent** outEvent,
+                                    int* motionEventType, int* touchMoveNumber, bool* flag) {
     if (DEBUG_TRANSPORT_ACTIONS) {
         ALOGD("channel '%s' consumer ~ consume: consumeBatches=%s, frameTime=%" PRId64,
               mChannel->getName().c_str(), toString(consumeBatches), frameTime);
@@ -628,10 +629,20 @@ status_t InputConsumer::consume(InputEventFactoryInterface* factory, bool consum
         } else {
             // Receive a fresh message.
             status_t result = mChannel->receiveMessage(&mMsg);
+            if (result == 0) {
+                if ((mMsg.body.motion.action & AMOTION_EVENT_ACTION_MASK) == AMOTION_EVENT_ACTION_MOVE){
+                    mTouchMoveCounter++;
+                } else {
+                    mTouchMoveCounter = 0;
+                }
+                *flag = true;
+            }
+            *motionEventType = mMsg.body.motion.action & AMOTION_EVENT_ACTION_MASK;
+            *touchMoveNumber = mTouchMoveCounter;
             if (result) {
                 // Consume the next batched event unless batches are being held for later.
                 if (consumeBatches || result != WOULD_BLOCK) {
-                    result = consumeBatch(factory, frameTime, outSeq, outEvent);
+                    result = consumeBatch(factory, frameTime, outSeq, outEvent, touchMoveNumber);
                     if (*outEvent) {
                         if (DEBUG_TRANSPORT_ACTIONS) {
                             ALOGD("channel '%s' consumer ~ consumed batch event, seq=%u",
@@ -748,7 +759,7 @@ status_t InputConsumer::consume(InputEventFactoryInterface* factory, bool consum
 }
 
 status_t InputConsumer::consumeBatch(InputEventFactoryInterface* factory,
-        nsecs_t frameTime, uint32_t* outSeq, InputEvent** outEvent) {
+        nsecs_t frameTime, uint32_t* outSeq, InputEvent** outEvent, int* touchMoveNumber) {
     status_t result;
     for (size_t i = mBatches.size(); i > 0; ) {
         i--;
@@ -760,7 +771,7 @@ status_t InputConsumer::consumeBatch(InputEventFactoryInterface* factory,
         }
 
         nsecs_t sampleTime = frameTime;
-        if (mResampleTouch) {
+        if (mResampleTouch && (*touchMoveNumber != 1)) {
             sampleTime -= RESAMPLE_LATENCY;
         }
         ssize_t split = findSampleNoLaterThan(batch, sampleTime);
-- 
2.17.1

