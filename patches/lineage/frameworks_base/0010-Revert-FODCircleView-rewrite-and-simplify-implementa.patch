From 4b5ebb7aafb1efbd52308c7c51c94a754a8ce54d Mon Sep 17 00:00:00 2001
From: Victor Bo <bvoid@yandex.ru>
Date: Mon, 10 Feb 2020 03:28:13 +0200
Subject: [PATCH 10/16] Revert "FODCircleView: rewrite and simplify
 implementation"

This reverts commit 9213b9f5aa79d25a9633df99a7922c4c7f72dfda.
---
 .../systemui/biometrics/FODCircleView.java    | 419 ++++++++++++------
 1 file changed, 276 insertions(+), 143 deletions(-)

diff --git a/packages/SystemUI/src/com/android/systemui/biometrics/FODCircleView.java b/packages/SystemUI/src/com/android/systemui/biometrics/FODCircleView.java
index 8f0b352d318..01205a9d134 100644
--- a/packages/SystemUI/src/com/android/systemui/biometrics/FODCircleView.java
+++ b/packages/SystemUI/src/com/android/systemui/biometrics/FODCircleView.java
@@ -24,15 +24,19 @@ import android.graphics.Color;
 import android.graphics.Paint;
 import android.graphics.PixelFormat;
 import android.graphics.Point;
+import android.hardware.biometrics.BiometricSourceType;
 import android.os.Handler;
+import android.os.IHwBinder;
 import android.os.Looper;
 import android.os.RemoteException;
+import android.os.SystemProperties;
 import android.provider.Settings;
 import android.view.Display;
 import android.view.Gravity;
 import android.view.MotionEvent;
 import android.view.Surface;
 import android.view.View;
+import android.view.View.OnTouchListener;
 import android.view.WindowManager;
 import android.widget.ImageView;
 
@@ -47,14 +51,15 @@ import java.util.NoSuchElementException;
 import java.util.Timer;
 import java.util.TimerTask;
 
-public class FODCircleView extends ImageView {
+public class FODCircleView extends ImageView implements OnTouchListener {
     private final int mPositionX;
     private final int mPositionY;
-    private final int mSize;
+    private final int mWidth;
+    private final int mHeight;
     private final int mDreamingMaxOffset;
-    private final int mNavigationBarSize;
     private final boolean mShouldBoostBrightness;
     private final Paint mPaintFingerprint = new Paint();
+    private final Paint mPaintShow = new Paint();
     private final WindowManager.LayoutParams mParams = new WindowManager.LayoutParams();
     private final WindowManager mWindowManager;
 
@@ -62,11 +67,16 @@ public class FODCircleView extends ImageView {
 
     private int mDreamingOffsetX;
     private int mDreamingOffsetY;
+    private int mNavigationBarSize;
 
     private boolean mIsBouncer;
     private boolean mIsDreaming;
-    private boolean mIsShowing;
-    private boolean mIsCircleShowing;
+    private boolean mIsInsideCircle;
+    private boolean mIsPressed;
+    private boolean mIsPulsing;
+    private boolean mIsScreenOn;
+    private boolean mIsViewAdded;
+    private boolean mIsRemoving;
 
     private Handler mHandler;
 
@@ -76,12 +86,26 @@ public class FODCircleView extends ImageView {
             new IFingerprintInscreenCallback.Stub() {
         @Override
         public void onFingerDown() {
-            mHandler.post(() -> showCircle());
+            mIsInsideCircle = true;
+
+            mHandler.post(() -> {
+                setDim(true);
+                setImageDrawable(null);
+
+                invalidate();
+            });
         }
 
         @Override
         public void onFingerUp() {
-            mHandler.post(() -> hideCircle());
+            mIsInsideCircle = false;
+
+            mHandler.post(() -> {
+                setDim(false);
+                setImageResource(R.drawable.fod_icon_default);
+
+                invalidate();
+            });
         }
     };
 
@@ -90,21 +114,60 @@ public class FODCircleView extends ImageView {
     private KeyguardUpdateMonitorCallback mMonitorCallback = new KeyguardUpdateMonitorCallback() {
         @Override
         public void onDreamingStateChanged(boolean dreaming) {
+            super.onDreamingStateChanged(dreaming);
             mIsDreaming = dreaming;
-            updateAlpha();
-
+            mIsInsideCircle = false;
             if (dreaming) {
                 mBurnInProtectionTimer = new Timer();
                 mBurnInProtectionTimer.schedule(new BurnInProtectionTask(), 0, 60 * 1000);
             } else if (mBurnInProtectionTimer != null) {
                 mBurnInProtectionTimer.cancel();
             }
+
+            if (mIsViewAdded) {
+                resetPosition();
+                invalidate();
+            }
+        }
+
+        @Override
+        public void onScreenTurnedOff() {
+            super.onScreenTurnedOff();
+            mIsInsideCircle = false;
+        }
+
+        @Override
+        public void onStartedGoingToSleep(int why) {
+            super.onStartedGoingToSleep(why);
+            mIsInsideCircle = false;
+        }
+
+        @Override
+        public void onFinishedGoingToSleep(int why) {
+            super.onFinishedGoingToSleep(why);
+        }
+
+        @Override
+        public void onStartedWakingUp() {
+            super.onStartedWakingUp();
+        }
+
+        @Override
+        public void onScreenTurnedOn() {
+            super.onScreenTurnedOn();
+            mIsScreenOn = true;
+            mIsInsideCircle = false;
+        }
+
+        @Override
+        public void onKeyguardVisibilityChanged(boolean showing) {
+            super.onKeyguardVisibilityChanged(showing);
+            mIsInsideCircle = false;
         }
 
         @Override
         public void onKeyguardBouncerChanged(boolean isBouncer) {
             mIsBouncer = isBouncer;
-
             if (isBouncer) {
                 hide();
             } else if (mUpdateMonitor.isFingerprintDetectionRunning()) {
@@ -113,57 +176,69 @@ public class FODCircleView extends ImageView {
         }
 
         @Override
-        public void onScreenTurnedOff() {
-            hideCircle();
+        public void onStrongAuthStateChanged(int userId) {
+            super.onStrongAuthStateChanged(userId);
         }
-    };
 
-    public FODCircleView(Context context) {
-        super(context);
-
-        IFingerprintInscreen daemon = getFingerprintInScreenDaemon();
-        if (daemon == null) {
-            throw new RuntimeException("Unable to get IFingerprintInscreen");
+        @Override
+        public void onBiometricAuthenticated(int userId, BiometricSourceType biometricSourceType) {
+            super.onBiometricAuthenticated(userId, biometricSourceType);
+            mIsInsideCircle = false;
         }
 
-        try {
-            mShouldBoostBrightness = daemon.shouldBoostBrightness();
-            mPositionX = daemon.getPositionX();
-            mPositionY = daemon.getPositionY();
-            mSize = daemon.getSize();
-        } catch (RemoteException e) {
-            throw new RuntimeException("Failed to retrieve FOD circle position or size");
+        @Override
+        public void onBiometricRunningStateChanged(boolean running,
+                BiometricSourceType biometricSourceType) {
+            super.onBiometricRunningStateChanged(running, biometricSourceType);
+            if (running) {
+                show();
+            } else {
+                hide();
+            }
         }
+    };
+
+    public FODCircleView(Context context) {
+        super(context);
 
         Resources res = context.getResources();
 
         mPaintFingerprint.setAntiAlias(true);
         mPaintFingerprint.setColor(res.getColor(R.color.config_fodColor));
 
+        setImageResource(R.drawable.fod_icon_default);
+
+        mPaintShow.setAntiAlias(true);
+        mPaintShow.setColor(res.getColor(R.color.config_fodColor));
+
+        setOnTouchListener(this);
+
         mWindowManager = context.getSystemService(WindowManager.class);
 
         mNavigationBarSize = res.getDimensionPixelSize(R.dimen.navigation_bar_size);
 
-        mDreamingMaxOffset = (int) (mSize * 0.1f);
-
-        mHandler = new Handler(Looper.getMainLooper());
+        try {
+            IFingerprintInscreen daemon = getFingerprintInScreenDaemon();
+            if (daemon == null) {
+                throw new RuntimeException("Unable to get IFingerprintInscreen");
+            }
+            mPositionX = daemon.getPositionX();
+            mPositionY = daemon.getPositionY();
+            mWidth = daemon.getSize();
+            mHeight = mWidth; // We do not expect mWidth != mHeight
 
-        mParams.height = mSize;
-        mParams.width = mSize;
-        mParams.format = PixelFormat.TRANSLUCENT;
+            mShouldBoostBrightness = daemon.shouldBoostBrightness();
+        } catch (NoSuchElementException | RemoteException e) {
+            throw new RuntimeException(e);
+        }
 
-        mParams.setTitle("Fingerprint on display");
-        mParams.packageName = "android";
-        mParams.type = WindowManager.LayoutParams.TYPE_DISPLAY_OVERLAY;
-        mParams.flags = WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE |
-                WindowManager.LayoutParams.FLAG_DIM_BEHIND |
-                WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN;
-        mParams.gravity = Gravity.TOP | Gravity.LEFT;
+        if (mPositionX < 0 || mPositionY < 0 || mWidth < 0 || mHeight < 0) {
+            throw new RuntimeException("Invalid FOD circle position or size.");
+        }
 
-        mWindowManager.addView(this, mParams);
+        mDreamingMaxOffset = (int) (mWidth * 0.1f);
 
-        updatePosition();
-        hide();
+        mHandler = new Handler(Looper.getMainLooper());
 
         mUpdateMonitor = KeyguardUpdateMonitor.getInstance(context);
         mUpdateMonitor.registerCallback(mMonitorCallback);
@@ -173,37 +248,126 @@ public class FODCircleView extends ImageView {
     protected void onDraw(Canvas canvas) {
         super.onDraw(canvas);
 
-        if (mIsCircleShowing) {
-            canvas.drawCircle(mSize / 2, mSize / 2, mSize / 2.0f, mPaintFingerprint);
+        if (mIsInsideCircle) {
+            canvas.drawCircle(mWidth / 2, mHeight / 2, (float) (mWidth / 2.0f), mPaintFingerprint);
+        }
+    }
+
+    @Override
+    protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
+        super.onLayout(changed, left, top, right, bottom);
+
+        // onLayout is a good time to call the HAL because dim layer
+        // added by setDim() should have come into effect
+        // the HAL is expected (if supported) to set the screen brightness
+        // to maximum / minimum immediately when called
+        if (mIsInsideCircle) {
+            if (mIsDreaming) {
+                setAlpha(1.0f);
+            }
+            if (!mIsPressed) {
+                IFingerprintInscreen daemon = getFingerprintInScreenDaemon();
+                if (daemon != null) {
+                    try {
+                        daemon.onPress();
+                    } catch (RemoteException e) {
+                        // do nothing
+                    }
+                }
+                mIsPressed = true;
+            }
+        } else {
+            setAlpha(mIsDreaming ? 0.5f : 1.0f);
+            if (mIsPressed) {
+                IFingerprintInscreen daemon = getFingerprintInScreenDaemon();
+                if (daemon != null) {
+                    try {
+                        daemon.onRelease();
+                    } catch (RemoteException e) {
+                        // do nothing
+                    }
+                }
+                mIsPressed = false;
+            }
+
+            if (mIsRemoving) {
+                mIsRemoving = false;
+                mWindowManager.removeView(this);
+            }
         }
     }
 
     @Override
-    public boolean onTouchEvent(MotionEvent event) {
+    public boolean onTouch(View v, MotionEvent event) {
         float x = event.getAxisValue(MotionEvent.AXIS_X);
         float y = event.getAxisValue(MotionEvent.AXIS_Y);
 
-        boolean newIsInside = (x > 0 && x < mSize) && (y > 0 && y < mSize);
+        boolean newInside = (x > 0 && x < mWidth) && (y > 0 && y < mWidth);
+
+        if (event.getAction() == MotionEvent.ACTION_UP) {
+            newInside = false;
+            setDim(false);
+            setImageResource(R.drawable.fod_icon_default);
+        }
+
+        if (newInside == mIsInsideCircle) {
+            return mIsInsideCircle;
+        }
+
+        mIsInsideCircle = newInside;
+
+        invalidate();
+
+        if (!mIsInsideCircle) {
+            setImageResource(R.drawable.fod_icon_default);
+            return false;
+        }
 
-        if (event.getAction() == MotionEvent.ACTION_DOWN && newIsInside) {
-            showCircle();
-            return true;
-        } else if (event.getAction() == MotionEvent.ACTION_UP) {
-            hideCircle();
-            return true;
-        } else if (event.getAction() == MotionEvent.ACTION_MOVE) {
-            return true;
+        if (event.getAction() == MotionEvent.ACTION_DOWN) {
+            setDim(true);
+            setImageDrawable(null);
         }
 
-        return false;
+        return true;
     }
 
     @Override
     public void onConfigurationChanged(Configuration newConfig) {
-        updatePosition();
+        if (mIsViewAdded) {
+            resetPosition();
+            mWindowManager.updateViewLayout(this, mParams);
+        }
     }
 
-    public IFingerprintInscreen getFingerprintInScreenDaemon() {
+    @Override
+    protected void onDetachedFromWindow() {
+        super.onDetachedFromWindow();
+
+        IFingerprintInscreen daemon = getFingerprintInScreenDaemon();
+        if (daemon != null) {
+            try {
+                daemon.onHideFODView();
+            } catch (RemoteException e) {
+                // do nothing
+            }
+        }
+    }
+
+    @Override
+    protected void onAttachedToWindow() {
+        super.onAttachedToWindow();
+
+        IFingerprintInscreen daemon = getFingerprintInScreenDaemon();
+        if (daemon != null) {
+            try {
+                daemon.onShowFODView();
+            } catch (RemoteException e) {
+                // do nothing
+            }
+        }
+    }
+
+    public synchronized IFingerprintInscreen getFingerprintInScreenDaemon() {
         if (mFingerprintInscreenDaemon == null) {
             try {
                 mFingerprintInscreenDaemon = IFingerprintInscreen.getService();
@@ -220,98 +384,59 @@ public class FODCircleView extends ImageView {
         return mFingerprintInscreenDaemon;
     }
 
-    public void dispatchPress() {
-        IFingerprintInscreen daemon = getFingerprintInScreenDaemon();
-        try {
-            daemon.onPress();
-        } catch (RemoteException e) {
-            // do nothing
+    public void show() {
+        if (mIsRemoving) {
+            // Last removal hasn't been finished yet
+            mIsRemoving = false;
+            mWindowManager.removeView(this);
         }
-    }
 
-    public void dispatchRelease() {
-        IFingerprintInscreen daemon = getFingerprintInScreenDaemon();
-        try {
-            daemon.onRelease();
-        } catch (RemoteException e) {
-            // do nothing
+        if (mIsViewAdded) {
+            return;
         }
-    }
 
-    public void dispatchShow() {
-        IFingerprintInscreen daemon = getFingerprintInScreenDaemon();
-        try {
-            daemon.onShowFODView();
-        } catch (RemoteException e) {
-            // do nothing
+        if (mIsBouncer) {
+            return;
         }
-    }
 
-    public void dispatchHide() {
-        IFingerprintInscreen daemon = getFingerprintInScreenDaemon();
-        try {
-            daemon.onHideFODView();
-        } catch (RemoteException e) {
-            // do nothing
-        }
-    }
+        resetPosition();
 
-    public void showCircle() {
-        mIsCircleShowing = true;
-
-        setKeepScreenOn(true);
-
-        setDim(true);
-        updateAlpha();
-        dispatchPress();
-
-        setImageDrawable(null);
-        invalidate();
-    }
+        mParams.height = mWidth;
+        mParams.width = mHeight;
+        mParams.format = PixelFormat.TRANSLUCENT;
 
-    public void hideCircle() {
-        mIsCircleShowing = false;
+        mParams.setTitle("Fingerprint on display");
+        mParams.packageName = "android";
+        mParams.type = WindowManager.LayoutParams.TYPE_DISPLAY_OVERLAY;
+        mParams.flags = WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE |
+                WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH |
+                WindowManager.LayoutParams.FLAG_DIM_BEHIND |
+                WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN;
+        mParams.gravity = Gravity.TOP | Gravity.LEFT;
 
         setImageResource(R.drawable.fod_icon_default);
-        invalidate();
 
-        dispatchRelease();
+        mWindowManager.addView(this, mParams);
+        mIsViewAdded = true;
 
+        mIsPressed = false;
         setDim(false);
-        updateAlpha();
-
-        setKeepScreenOn(false);
     }
 
-    public void show() {
-        if (mIsBouncer) {
-            // Ignore show calls when Keyguard pin screen is being shown
+    public void hide() {
+        if (!mIsViewAdded) {
             return;
         }
 
-        mIsShowing = true;
-
-        dispatchShow();
-        setVisibility(View.VISIBLE);
-    }
-
-    public void hide() {
-        mIsShowing = false;
-
-        setVisibility(View.GONE);
-        hideCircle();
-        dispatchHide();
-    }
-
-    private void updateAlpha() {
-        if (mIsCircleShowing) {
-            setAlpha(1.0f);
-        } else {
-            setAlpha(mIsDreaming ? 0.5f : 1.0f);
-        }
+        mIsInsideCircle = false;
+        mIsViewAdded = false;
+        // Postpone removal to next re-layout to avoid blinking
+        mIsRemoving = true;
+        setDim(false);
+        invalidate();
     }
 
-    private void updatePosition() {
+    private void resetPosition() {
         Display defaultDisplay = mWindowManager.getDefaultDisplay();
 
         Point size = new Point();
@@ -329,10 +454,10 @@ public class FODCircleView extends ImageView {
                 break;
             case Surface.ROTATION_180:
                 mParams.x = mPositionX;
-                mParams.y = size.y - mPositionY - mSize;
+                mParams.y = size.y - mPositionY - mHeight;
                 break;
             case Surface.ROTATION_270:
-                mParams.x = size.x - mPositionY - mSize - mNavigationBarSize;
+                mParams.x = size.x - mPositionY - mWidth - mNavigationBarSize;
                 mParams.y = mPositionX;
                 break;
             default:
@@ -344,7 +469,9 @@ public class FODCircleView extends ImageView {
             mParams.y += mDreamingOffsetY;
         }
 
-        mWindowManager.updateViewLayout(this, mParams);
+        if (mIsViewAdded) {
+            mWindowManager.updateViewLayout(this, mParams);
+        }
     }
 
     private void setDim(boolean dim) {
@@ -354,45 +481,51 @@ public class FODCircleView extends ImageView {
             int dimAmount = 0;
 
             IFingerprintInscreen daemon = getFingerprintInScreenDaemon();
-            try {
-                dimAmount = daemon.getDimAmount(curBrightness);
-            } catch (RemoteException e) {
-                // do nothing
+            if (daemon != null) {
+                try {
+                    dimAmount = daemon.getDimAmount(curBrightness);
+                } catch (RemoteException e) {
+                    // do nothing
+                }
             }
 
             if (mShouldBoostBrightness) {
                 mParams.screenBrightness = 1.0f;
             }
 
-            mParams.dimAmount = dimAmount / 255.0f;
+            mParams.dimAmount = ((float) dimAmount) / 255.0f;
         } else {
             mParams.screenBrightness = 0.0f;
             mParams.dimAmount = 0.0f;
         }
 
-        mWindowManager.updateViewLayout(this, mParams);
+        try {
+            mWindowManager.updateViewLayout(this, mParams);
+        } catch (IllegalArgumentException e) {
+            // do nothing
+        }
     }
 
     private class BurnInProtectionTask extends TimerTask {
         @Override
         public void run() {
+            // It is fine to modify the variables here because
+            // no other thread will be modifying it
             long now = System.currentTimeMillis() / 1000 / 60;
-
             mDreamingOffsetX = (int) (now % (mDreamingMaxOffset * 4));
             if (mDreamingOffsetX > mDreamingMaxOffset * 2) {
                 mDreamingOffsetX = mDreamingMaxOffset * 4 - mDreamingOffsetX;
             }
-
             // Let y to be not synchronized with x, so that we get maximum movement
             mDreamingOffsetY = (int) ((now + mDreamingMaxOffset / 3) % (mDreamingMaxOffset * 2));
             if (mDreamingOffsetY > mDreamingMaxOffset * 2) {
                 mDreamingOffsetY = mDreamingMaxOffset * 4 - mDreamingOffsetY;
             }
-
             mDreamingOffsetX -= mDreamingMaxOffset;
             mDreamingOffsetY -= mDreamingMaxOffset;
-
-            mHandler.post(() -> updatePosition());
+            if (mIsViewAdded) {
+                mHandler.post(() -> resetPosition());
+            }
         }
     };
 }
-- 
2.17.1

